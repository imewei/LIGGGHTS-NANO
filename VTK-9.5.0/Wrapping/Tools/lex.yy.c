#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

#ifndef __cplusplus
extern int isatty(int);
#endif /* __cplusplus */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state* YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                                                                          \
  do                                                                                               \
  {                                                                                                \
    int yyl;                                                                                       \
    for (yyl = n; yyl < yyleng; ++yyl)                                                             \
      if (yytext[yyl] == '\n')                                                                     \
        --yylineno;                                                                                \
  } while (0)
#define YY_LINENO_REWIND_TO(dst)                                                                   \
  do                                                                                               \
  {                                                                                                \
    const char* p;                                                                                 \
    for (p = yy_cp - 1; p >= (dst); --p)                                                           \
      if (*p == '\n')                                                                              \
        --yylineno;                                                                                \
  } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp = (yy_hold_char);                                                                       \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  FILE* yy_input_file;

  char* yy_ch_buf;  /* input buffer */
  char* yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE* yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE* input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char* yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char* bytes, int len);

void* yyalloc(yy_size_t);
void* yyrealloc(void*, yy_size_t);
void yyfree(void*);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }
#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char* yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char* msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  yyleng = (int)(yy_cp - yy_bp);                                                                   \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp = '\0';                                                                                   \
  (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 167
#define YY_END_OF_BUFFER 168
static const flex_int16_t yy_accept[976] = { 0, 0, 0, 168, 166, 130, 131, 131, 165, 166, 165, 165,
  166, 165, 165, 165, 165, 165, 165, 165, 128, 127, 165, 165, 165, 165, 119, 119, 119, 119, 119,
  119, 119, 119, 163, 166, 164, 165, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 165, 130, 13, 13, 15, 165, 166, 130, 158, 0, 16, 0, 137,
  151, 134, 155, 152, 0, 0, 0, 90, 91, 0, 0, 0, 0, 0, 149, 145, 147, 146, 148, 144, 142, 0, 120, 3,
  14, 150, 0, 121, 126, 0,

  0, 0, 0, 0, 127, 127, 127, 162, 136, 133, 135, 141, 159, 157, 160, 138, 119, 119, 119, 0, 0, 119,
  119, 119, 0, 119, 0, 132, 129, 0, 154, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 81,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
  119, 153, 156, 130, 13, 15, 0, 0, 15, 15, 3, 12, 0, 17, 0, 18, 0, 0,

  0, 0, 0, 0, 143, 161, 0, 120, 120, 120, 0, 14, 14, 122, 121, 121, 126, 126, 0, 125, 0, 123, 124,
  127, 123, 139, 140, 119, 119, 119, 0, 0, 19, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 79, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 26, 119, 119, 119, 119, 65, 119, 83, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 69, 119, 119, 119,

  119, 119, 119, 119, 119, 119, 85, 0, 12, 15, 2, 12, 12, 6, 12, 0, 0, 17, 0, 18, 0, 0, 0, 0, 0, 0,
  0, 0, 120, 0, 120, 1, 5, 0, 122, 122, 122, 121, 0, 121, 126, 123, 0, 125, 125, 0, 123, 123, 0,
  124, 124, 124, 123, 123, 119, 119, 119, 0, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 20, 119, 119, 30, 119, 25, 119, 119, 119, 119, 119,
  119, 119, 119, 47, 119, 119, 119, 119, 119, 119, 24,

  119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 0, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 29, 119, 119, 119, 119, 2, 12, 12, 6, 12, 12, 12, 6,
  5, 7, 8, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 120, 120, 5, 122, 0, 122, 121, 0, 121, 121,
  123, 123, 125, 123, 124, 124, 124, 124, 123, 119, 119, 119, 101, 119, 119, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,

  119, 119, 88, 70, 119, 119, 42, 89, 50, 119, 119, 119, 119, 119, 119, 119, 22, 119, 119, 119, 119,
  119, 119, 119, 119, 119, 82, 119, 119, 119, 119, 119, 119, 23, 119, 119, 119, 119, 119, 0, 119,
  119, 119, 119, 68, 119, 119, 48, 119, 64, 119, 119, 119, 119, 119, 12, 12, 6, 7, 8, 12, 12, 12, 5,
  7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 122, 0, 122, 122, 121, 123, 119, 119, 119, 101, 96, 119,
  119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,

  119, 119, 119, 119, 119, 119, 80, 87, 119, 119, 119, 119, 119, 119, 66, 21, 119, 119, 59, 54, 55,
  119, 119, 119, 119, 84, 119, 119, 119, 119, 119, 44, 119, 119, 119, 28, 119, 119, 57, 0, 0, 0, 0,
  119, 43, 119, 119, 119, 119, 119, 119, 119, 119, 119, 86, 12, 12, 12, 7, 8, 12, 12, 12, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 122, 119, 119, 119, 95, 119, 107, 119, 119, 109, 119, 119, 114, 119, 119,
  119, 119, 119, 119, 119, 119, 119, 103, 119, 119, 119, 119,

  119, 73, 119, 119, 119, 52, 119, 119, 118, 119, 119, 45, 119, 0, 119, 119, 119, 34, 34, 119, 119,
  0, 0, 0, 0, 0, 0, 99, 99, 119, 119, 62, 119, 119, 49, 119, 119, 33, 12, 12, 12, 12, 12, 12, 0, 0,
  0, 0, 0, 93, 94, 0, 0, 0, 0, 0, 96, 96, 37, 104, 105, 119, 119, 119, 119, 119, 119, 119, 117, 110,
  119, 119, 119, 31, 32, 119, 119, 72, 119, 67, 98, 98, 119, 71, 119, 53, 97, 97, 0, 119, 0, 78,
  119, 0, 41, 35, 35, 119, 119, 0,

  0, 0, 0, 0, 0, 60, 119, 61, 27, 51, 119, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0,
  108, 119, 119, 119, 119, 119, 119, 119, 119, 56, 119, 63, 119, 0, 46, 0, 119, 119, 119, 0, 0, 0,
  0, 0, 0, 119, 119, 12, 12, 12, 10, 12, 12, 0, 0, 0, 0, 119, 119, 113, 119, 116, 76, 119, 36, 36,
  0, 0, 0, 119, 119, 119, 0, 0, 0, 0, 0, 0, 119, 119, 10, 12, 12, 10, 12, 12, 0, 4, 119, 112, 119,
  119, 119,

  0, 0, 0, 119, 119, 74, 0, 0, 0, 0, 0, 0, 119, 119, 10, 12, 12, 12, 12, 0, 119, 119, 119, 115, 75,
  0, 0, 0, 119, 119, 0, 0, 0, 0, 58, 100, 12, 12, 11, 12, 0, 106, 111, 0, 0, 0, 38, 119, 102, 0, 11,
  12, 11, 12, 0, 0, 39, 0, 119, 0, 11, 12, 12, 0, 0, 119, 12, 9, 0, 40, 77, 9, 9, 9, 0 };

static const YY_CHAR yy_ec[256] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 4, 5, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 7, 8, 9, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 24, 25, 25, 26, 25, 27, 28, 29, 17, 30, 31, 32, 1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 41, 55, 56, 57, 41, 58, 59, 60, 61, 62, 1, 63, 64,
  65, 66,

  67, 68, 69, 70, 71, 41, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 17, 1, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91,

  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91 };

static const YY_CHAR yy_meta[92] = { 0, 1, 2, 3, 4, 5, 2, 1, 1, 1, 1, 6, 7, 1, 4, 6, 1, 1, 1, 8, 1,
  9, 9, 10, 10, 10, 10, 10, 10, 11, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 13, 12, 12, 12, 12, 12, 12, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 14

};

static const flex_int16_t yy_base[1081] = { 0, 0, 90, 2760, 2761, 92, 2761, 2761, 2728, 89, 71, 90,
  2699, 102, 2761, 2726, 93, 88, 107, 96, 153, 128, 83, 115, 2725, 110, 2706, 0, 2720, 131, 56,
  2745, 150, 2710, 165, 156, 2761, 2720, 149, 111, 114, 124, 132, 88, 131, 132, 2674, 2667, 152,
  126, 134, 2681, 151, 157, 217, 159, 2682, 2670, 161, 243, 2761, 2761, 2686, 222, 2673, 245, 2761,
  206, 0, 2738, 2761, 2761, 2761, 2761, 2761, 214, 157, 255, 2761, 2761, 210, 2713, 233, 212, 226,
  2761, 2761, 2761, 2761, 2761, 2726, 2761, 2721, 257, 249, 267, 2761, 277, 304, 322, 340,

  250, 358, 0, 369, 387, 0, 405, 2761, 2761, 2761, 2761, 2708, 2761, 2761, 2761, 2707, 0, 2695,
  2691, 278, 2676, 2726, 2685, 2703, 2718, 2683, 317, 2761, 2761, 2726, 2761, 233, 2661, 2651, 2647,
  2655, 371, 2653, 2657, 2641, 2640, 2644, 2638, 2655, 2654, 219, 243, 2634, 2640, 2632, 232, 2637,
  2641, 234, 2630, 2635, 2628, 2634, 2623, 254, 2633, 2638, 2642, 2622, 262, 2638, 206, 2625, 249,
  2629, 290, 2625, 2619, 2611, 2619, 365, 364, 2624, 2615, 284, 2621, 2622, 2612, 2761, 2761, 453,
  2761, 2631, 383, 2618, 2629, 415, 431, 457, 265, 0, 416, 0, 2658, 2657,

  358, 267, 325, 411, 2761, 2761, 444, 472, 0, 490, 2655, 0, 2654, 507, 0, 525, 0, 538, 499, 466,
  554, 571, 588, 0, 607, 2761, 2761, 2645, 2637, 2646, 2651, 2666, 2761, 2644, 2606, 2600, 2600,
  2595, 2610, 2593, 2590, 285, 2603, 325, 2594, 2589, 2600, 2585, 2595, 2595, 2601, 2586, 341, 2588,
  2595, 2580, 2578, 2580, 2576, 2582, 2591, 2586, 2588, 2588, 2576, 2576, 2581, 2584, 2579, 2574, 0,
  2565, 2574, 2579, 2574, 0, 2555, 2577, 2565, 2558, 2569, 2556, 2551, 2552, 2559, 2560, 2555, 2550,
  2553, 2560, 2539, 2544, 2595, 378, 2546, 413, 0, 2555, 2545, 2549,

  2544, 2537, 2551, 2553, 2563, 2551, 2551, 438, 551, 402, 2582, 0, 464, 2581, 353, 2533, 2528, 0,
  477, 0, 492, 579, 540, 475, 572, 418, 341, 573, 0, 636, 653, 2761, 0, 645, 670, 0, 688, 0, 662,
  705, 0, 722, 516, 625, 0, 697, 730, 0, 0, 747, 804, 0, 766, 0, 2561, 2572, 2563, 0, 2556, 2535,
  2529, 2535, 2534, 2531, 2532, 2517, 2530, 2517, 2530, 2514, 2514, 2519, 2528, 2510, 2523, 2517,
  2512, 2508, 0, 2486, 2478, 0, 2486, 518, 2453, 2446, 2434, 2433, 2419, 2419, 2414, 2412, 0, 2402,
  2393, 2378, 2383, 2360, 2354, 0,

  2351, 2329, 2341, 2334, 2318, 2329, 2309, 2317, 2316, 2309, 2286, 2263, 2248, 2234, 505, 2239,
  2220, 2202, 2230, 2178, 2182, 2168, 2172, 2145, 573, 2151, 2152, 2146, 2127, 0, 2122, 2119, 2116,
  2122, 2761, 0, 536, 0, 498, 589, 2119, 0, 0, 0, 0, 2108, 2111, 0, 558, 615, 453, 575, 541, 538,
  574, 578, 796, 739, 823, 0, 0, 0, 774, 852, 869, 831, 877, 0, 894, 0, 0, 0, 911, 968, 0, 0, 0,
  2120, 2136, 2127, 0, 2109, 2070, 2068, 2057, 2050, 2054, 2054, 2024, 2024, 2010, 1988, 1966, 1968,
  1948, 1941, 1923, 1933, 1915, 1927,

  1906, 1915, 0, 0, 1950, 1950, 0, 0, 638, 1884, 1891, 1891, 1888, 1879, 1879, 1868, 0, 1875, 1869,
  1870, 1855, 1845, 1852, 1836, 1827, 1821, 0, 1836, 1805, 1815, 1812, 1785, 1798, 0, 1791, 1797,
  1781, 1795, 1778, 880, 1760, 1742, 1757, 1749, 0, 1745, 1744, 0, 1729, 0, 1736, 1727, 1730, 1729,
  1707, 655, 1712, 0, 0, 0, 1742, 1733, 1682, 0, 0, 0, 1681, 1656, 750, 706, 882, 674, 712, 780,
  878, 804, 940, 960, 987, 1016, 0, 1033, 0, 1683, 1697, 1692, 0, 1675, 1655, 1645, 1625, 1608,
  1624, 1599, 1588, 1580, 1582, 1564, 1578, 1575,

  1566, 1564, 1549, 1540, 1537, 1521, 0, 0, 1538, 1537, 1533, 1512, 1519, 1514, 0, 0, 1529, 1522, 0,
  0, 0, 1518, 1524, 1527, 1512, 0, 1509, 1511, 1512, 1518, 1503, 860, 1516, 1503, 1501, 0, 1061,
  1499, 1517, 1498, 1491, 1492, 860, 1152, 0, 1490, 1508, 1501, 1494, 1500, 1493, 1492, 1512, 1482,
  0, 1528, 1523, 1480, 0, 0, 1513, 1522, 1492, 1482, 1487, 831, 987, 1094, 707, 879, 988, 881, 1066,
  1089, 1497, 1509, 1499, 0, 1471, 0, 1485, 1433, 0, 1449, 1446, 0, 1436, 1431, 1444, 1435, 1438,
  1441, 1432, 1429, 1438, 0, 1419, 1418, 1435, 1420,

  1429, 0, 1433, 1413, 1243, 0, 1428, 1411, 1429, 1411, 1334, 923, 1422, 1024, 1409, 1410, 995,
  2761, 0, 1425, 526, 1401, 1408, 1399, 1392, 1407, 1398, 2761, 0, 1409, 1402, 0, 1407, 1407, 0,
  1405, 1390, 0, 1424, 1433, 1403, 1429, 1413, 1386, 1397, 1400, 747, 577, 1122, 2761, 1433, 1185,
  854, 989, 857, 1069, 1412, 1411, 0, 0, 0, 1384, 1348, 1338, 1346, 1351, 1344, 1341, 0, 0, 1350,
  1341, 1340, 0, 0, 1332, 1332, 0, 1345, 0, 2761, 0, 1342, 0, 1327, 0, 2761, 0, 1136, 1341, 1332, 0,
  1325, 1100, 2761, 2761, 0, 1323, 1339, 1321,

  1326, 1319, 1330, 1304, 1319, 0, 1313, 0, 0, 0, 1309, 1349, 1333, 1306, 1378, 1339, 1305, 1296,
  1303, 1190, 1276, 1215, 2761, 880, 884, 885, 1116, 0, 1254, 1248, 1263, 1254, 1253, 1243, 1250,
  1241, 0, 1257, 0, 1516, 1246, 1044, 1242, 1250, 1235, 1234, 1246, 1235, 1244, 1247, 1241, 1232,
  1241, 1228, 1290, 1246, 1214, 0, 1232, 1160, 1155, 1168, 1165, 1204, 1169, 1165, 0, 1160, 1167, 0,
  1148, 2761, 0, 1151, 1220, 1143, 1134, 1142, 1127, 1144, 1125, 1141, 1122, 1140, 1132, 1136, 1123,
  0, 1149, 37, 0, 186, 209, 339, 2761, 394, 443, 469, 528, 618,

  620, 665, 725, 744, 728, 0, 760, 757, 763, 0, 804, 0, 814, 819, 0, 865, 873, 953, 898, 889, 898,
  911, 932, 0, 0, 939, 944, 1281, 956, 941, 0, 963, 0, 0, 0, 0, 1042, 980, 0, 1031, 1037, 0, 0,
  1287, 1037, 1292, 2761, 1063, 0, 1049, 0, 1057, 0, 1059, 1059, 1367, 2761, 1056, 1060, 0, 0, 1069,
  1117, 1072, 1372, 1067, 1157, 0, 1377, 2761, 0, 0, 0, 0, 2761, 1607, 1621, 1634, 1642, 1648, 1662,
  1665, 1671, 1679, 1693, 1699, 1707, 1713, 1717, 1731, 1745, 1751, 1754, 1760, 1768, 1774, 1780,
  1788, 1796, 1804,

  1812, 1826, 1840, 1846, 1855, 1861, 1869, 1883, 1891, 1897, 1903, 1911, 1917, 1925, 1933, 1939,
  1947, 1953, 1959, 1965, 1973, 1979, 1987, 1993, 1999, 2002, 2016, 2030, 2044, 2058, 2072, 2086,
  2100, 2106, 2112, 2120, 2128, 2134, 2148, 2154, 2162, 2170, 2178, 2184, 2192, 2198, 2204, 2210,
  2218, 2224, 2230, 2236, 2242, 2256, 2270, 2284, 2298, 2312, 2326, 2340, 2354, 2360, 2368, 2376,
  2384, 2390, 2398, 2404, 2418, 2432, 2446, 2460, 2474, 2488, 2502, 2516, 2530, 2544, 2558, 2572 };

static const flex_int16_t yy_def[1081] = { 0, 975, 1, 975, 975, 975, 975, 975, 975, 976, 975, 975,
  977, 978, 975, 975, 975, 975, 975, 975, 975, 979, 975, 975, 975, 975, 980, 980, 980, 980, 980,
  980, 980, 980, 975, 975, 975, 975, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 975, 975, 975, 975, 981, 975, 975, 975, 975, 976, 982,
  976, 975, 975, 975, 975, 975, 977, 977, 978, 975, 975, 983, 983, 983, 983, 983, 975, 975, 975,
  975, 975, 975, 975, 975, 984, 975, 985, 975, 975, 986, 987, 975,

  975, 975, 988, 975, 979, 989, 989, 975, 975, 975, 975, 975, 975, 975, 975, 975, 980, 980, 980,
  976, 977, 980, 980, 980, 990, 980, 975, 975, 975, 975, 975, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 975, 975, 975, 975, 981, 975, 975, 981, 981, 975, 991, 975,
  992, 976, 993, 983, 975,

  983, 983, 983, 983, 975, 975, 975, 984, 994, 994, 975, 985, 985, 995, 996, 996, 997, 997, 975,
  998, 975, 999, 1000, 989, 1001, 975, 975, 980, 980, 980, 975, 990, 975, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980,

  980, 980, 980, 980, 980, 980, 980, 975, 1002, 981, 975, 991, 991, 1003, 991, 975, 975, 992, 976,
  1004, 1005, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 994, 975, 1007, 975, 1008, 975, 1009, 1010,
  1010, 1011, 975, 1012, 1013, 1014, 975, 1015, 1016, 975, 1017, 1018, 1019, 1020, 1021, 1022, 1023,
  1024, 1025, 1025, 1025, 1026, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
  1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
  1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,

  1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
  1025, 1025, 975, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
  1025, 1025, 975, 1027, 1027, 1028, 1027, 1029, 1029, 1030, 1031, 1032, 1033, 975, 975, 1034, 1035,
  1035, 1035, 1035, 1035, 1035, 1035, 1035, 1036, 975, 1037, 1038, 1039, 1040, 975, 1041, 1042, 975,
  1043, 1044, 1045, 1046, 1047, 1048, 1049, 1049, 1050, 1050, 1051, 1052, 1052, 1052, 1053, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052,

  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 975, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1054, 1054, 1055, 1056, 1057, 1058, 1058, 1058, 1059,
  1060, 1061, 975, 975, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1063, 1064, 975, 1065, 1066,
  1067, 1068, 1052, 1052, 1052, 1053, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052,

  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 975, 975, 975, 975, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1054, 1054, 1054, 1056, 1057, 1058, 1058, 1058, 975, 975,
  1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1064, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052,

  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 975, 1052, 1052,
  1052, 975, 1052, 1052, 1052, 975, 975, 975, 975, 975, 975, 975, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1054, 1054, 1054, 1058, 1058, 1058, 975, 975, 1062, 1062, 975, 975,
  1062, 1062, 1062, 1062, 1062, 1062, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 975, 1052,
  1052, 1052, 1052, 1052, 975, 1052, 975, 1052, 975, 1052, 1052, 975, 975, 975, 1052, 1052, 1052,
  975,

  975, 975, 975, 975, 975, 1052, 1052, 1052, 1052, 1052, 1052, 1054, 1054, 1054, 1058, 1058, 1058,
  975, 975, 1062, 1062, 975, 975, 1062, 1062, 1062, 1062, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 1052, 1052, 1052, 975, 1052, 975, 1052, 1052, 1052, 975, 975, 975, 975, 975,
  975, 1052, 1052, 1054, 1054, 1054, 1069, 1058, 1058, 975, 975, 1062, 1062, 1052, 1052, 1052, 1052,
  1052, 1052, 1052, 975, 1052, 975, 975, 975, 1052, 1052, 1052, 975, 975, 975, 975, 975, 975, 1052,
  1052, 1070, 1054, 1054, 1069, 1058, 1058, 975, 975, 1052, 1052, 1052, 1052, 1052,

  975, 975, 975, 1052, 1052, 1052, 975, 975, 975, 1071, 975, 1072, 1052, 1052, 1070, 1054, 1054,
  1058, 1058, 975, 1052, 1052, 1052, 1052, 1052, 975, 975, 975, 1052, 1052, 1073, 975, 1074, 1075,
  1052, 1052, 1054, 1054, 1076, 1058, 975, 1052, 1052, 975, 975, 975, 975, 1052, 1052, 975, 1077,
  1054, 1076, 1058, 975, 975, 975, 975, 1052, 1078, 1077, 1054, 1058, 975, 975, 1052, 1054, 1079,
  975, 975, 1052, 1080, 1079, 1080, 0, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,

  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975 };

static const flex_int16_t yy_nxt[2853] = { 0, 4, 5, 6, 7, 7, 5, 8, 9, 4, 10, 11, 12, 13, 14, 15, 16,
  14, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 25, 4, 26, 27, 28, 27, 27, 27, 27, 27,
  27, 27, 27, 29, 27, 27, 27, 27, 30, 31, 27, 27, 32, 33, 27, 27, 34, 35, 36, 37, 38, 39, 40, 41,
  42, 43, 44, 27, 27, 45, 27, 46, 47, 48, 49, 50, 27, 51, 52, 53, 54, 55, 56, 57, 27, 27, 14, 58,
  14, 27, 59, 60, 65, 61, 59, 68, 65, 62, 70,

  73, 71, 72, 77, 77, 88, 77, 77, 86, 63, 94, 108, 78, 917, 109, 95, 79, 123, 89, 90, 74, 91, 64,
  87, 110, 92, 96, 93, 93, 93, 93, 93, 93, 93, 93, 80, 124, 82, 120, 104, 115, 116, 121, 111, 112,
  113, 98, 69, 105, 105, 105, 105, 105, 105, 105, 105, 83, 120, 129, 975, 130, 121, 150, 84, 97,
  107, 127, 127, 75, 127, 127, 98, 151, 99, 99, 99, 99, 99, 99, 99, 100, 122, 132, 138, 141, 139,
  143, 101, 133, 142, 102, 184, 140, 144, 107, 134, 145, 135, 147, 146,

  122, 136, 162, 152, 163, 164, 154, 148, 103, 153, 137, 155, 165, 68, 158, 166, 101, 149, 159, 102,
  168, 169, 128, 172, 120, 198, 173, 160, 121, 179, 170, 171, 918, 161, 180, 174, 193, 103, 200,
  181, 200, 194, 175, 176, 186, 187, 65, 187, 186, 185, 65, 188, 96, 203, 200, 211, 77, 77, 201, 77,
  77, 200, 189, 211, 69, 78, 202, 122, 207, 79, 220, 220, 76, 213, 286, 190, 287, 208, 208, 208,
  208, 208, 208, 208, 208, 68, 213, 204, 80, 919, 82, 177, 258, 259, 210, 200, 178, 99, 99, 99,

  99, 99, 99, 99, 100, 235, 270, 260, 266, 83, 261, 323, 267, 236, 271, 262, 84, 289, 127, 127, 277,
  127, 127, 210, 214, 214, 214, 214, 214, 214, 214, 214, 283, 97, 278, 290, 69, 284, 316, 317, 98,
  216, 99, 99, 99, 99, 99, 99, 99, 100, 367, 219, 292, 200, 303, 293, 304, 368, 98, 218, 100, 100,
  100, 100, 100, 100, 100, 100, 294, 200, 216, 324, 120, 221, 128, 221, 121, 102, 222, 222, 222,
  222, 222, 222, 222, 222, 200, 370, 218, 105, 105, 105, 105, 105, 105, 105, 105, 308, 104, 322,

  371, 920, 309, 380, 191, 98, 102, 105, 105, 105, 105, 105, 105, 105, 105, 122, 381, 191, 319, 310,
  221, 455, 221, 68, 107, 225, 225, 225, 225, 225, 225, 225, 225, 241, 299, 242, 243, 311, 244, 200,
  444, 245, 445, 300, 435, 311, 200, 246, 420, 247, 248, 249, 435, 107, 186, 187, 921, 187, 186,
  421, 192, 188, 313, 314, 208, 208, 208, 208, 208, 208, 208, 208, 189, 192, 69, 325, 314, 343, 326,
  423, 454, 200, 440, 207, 68, 190, 344, 344, 424, 315, 327, 328, 208, 208, 208, 208, 208, 208, 208,
  208,

  441, 571, 78, 200, 922, 330, 79, 330, 451, 210, 331, 331, 331, 331, 331, 331, 331, 331, 334, 100,
  100, 100, 100, 100, 100, 100, 100, 335, 335, 335, 335, 335, 335, 335, 335, 69, 344, 344, 210, 505,
  339, 506, 339, 923, 337, 340, 340, 340, 340, 340, 340, 340, 340, 221, 556, 221, 437, 438, 342,
  342, 342, 342, 342, 342, 342, 342, 200, 535, 200, 200, 438, 536, 557, 337, 222, 222, 222, 222,
  222, 222, 222, 222, 346, 439, 450, 559, 200, 560, 798, 924, 799, 347, 347, 347, 347, 347, 347,
  347, 347, 349,

  200, 200, 200, 200, 569, 200, 200, 200, 350, 350, 350, 350, 350, 350, 350, 350, 449, 574, 346,
  573, 821, 351, 351, 351, 351, 351, 351, 353, 353, 353, 353, 353, 353, 353, 353, 561, 343, 452,
  546, 575, 562, 572, 456, 200, 453, 344, 344, 547, 576, 570, 351, 351, 351, 351, 351, 351, 457,
  457, 457, 457, 457, 457, 457, 457, 458, 335, 335, 335, 335, 335, 335, 335, 335, 459, 459, 459,
  459, 459, 459, 459, 459, 334, 465, 465, 465, 465, 465, 465, 465, 465, 335, 335, 335, 335, 335,
  335, 335, 335, 925, 611,

  926, 656, 200, 463, 612, 463, 657, 337, 464, 464, 464, 464, 464, 464, 464, 464, 466, 347, 347,
  347, 347, 347, 347, 347, 347, 467, 467, 467, 467, 467, 467, 467, 467, 346, 200, 200, 337, 927,
  669, 667, 200, 346, 469, 469, 469, 469, 469, 469, 469, 469, 347, 347, 347, 347, 347, 347, 347,
  347, 349, 577, 577, 577, 577, 577, 577, 577, 577, 350, 350, 350, 350, 350, 350, 350, 350, 200,
  670, 346, 200, 752, 351, 351, 351, 351, 351, 351, 353, 353, 353, 353, 353, 353, 353, 353, 578,
  578, 578, 578, 578, 578,

  578, 578, 666, 820, 928, 929, 930, 458, 200, 351, 351, 351, 351, 351, 351, 349, 577, 577, 577,
  577, 577, 577, 577, 577, 473, 473, 473, 473, 473, 473, 473, 473, 200, 931, 458, 932, 933, 474,
  474, 474, 474, 474, 474, 459, 459, 459, 459, 459, 459, 459, 459, 582, 582, 582, 582, 582, 582,
  582, 582, 200, 671, 714, 714, 579, 714, 714, 474, 474, 474, 474, 474, 474, 580, 580, 580, 580,
  580, 580, 580, 580, 466, 747, 200, 673, 934, 200, 935, 936, 466, 582, 582, 582, 582, 582, 582,
  582, 582, 467, 467, 467,

  467, 467, 467, 467, 467, 346, 200, 200, 200, 200, 200, 937, 200, 200, 469, 469, 469, 469, 469,
  469, 469, 469, 349, 668, 789, 789, 824, 789, 789, 826, 725, 473, 473, 473, 473, 473, 473, 473,
  473, 726, 727, 753, 672, 755, 474, 474, 474, 474, 474, 474, 640, 458, 752, 938, 641, 642, 863,
  752, 939, 643, 577, 577, 577, 577, 577, 577, 577, 577, 940, 941, 942, 579, 943, 474, 474, 474,
  474, 474, 474, 349, 674, 674, 674, 674, 674, 674, 674, 674, 473, 473, 473, 473, 473, 473, 473,
  473, 794, 794, 769, 794,

  794, 474, 474, 474, 474, 474, 474, 674, 674, 674, 674, 674, 674, 674, 674, 200, 200, 200, 944,
  945, 948, 949, 748, 795, 950, 714, 714, 579, 714, 714, 474, 474, 474, 474, 474, 474, 580, 580,
  580, 580, 580, 580, 580, 580, 466, 875, 875, 951, 875, 875, 952, 825, 754, 582, 582, 582, 582,
  582, 582, 582, 582, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718,
  718, 718, 718, 718, 718, 719, 719, 719, 719, 719, 719, 719, 719, 718, 718, 718, 718, 718, 200,
  749, 749, 200, 749, 749,

  579, 794, 794, 791, 794, 794, 954, 955, 750, 674, 674, 674, 674, 674, 674, 674, 674, 958, 718,
  718, 718, 718, 200, 749, 749, 959, 749, 749, 795, 960, 756, 827, 962, 963, 964, 965, 750, 789,
  789, 966, 789, 789, 751, 967, 200, 968, 895, 971, 718, 718, 718, 719, 728, 728, 728, 728, 728,
  728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 729, 729, 729, 729,
  729, 729, 729, 729, 728, 728, 728, 728, 728, 972, 822, 822, 864, 822, 822, 749, 749, 200, 749,
  749, 916, 914, 913, 823,

  912, 911, 910, 909, 750, 908, 907, 906, 905, 728, 728, 728, 728, 200, 904, 841, 822, 822, 200,
  822, 822, 875, 875, 903, 875, 875, 901, 900, 899, 823, 898, 897, 200, 896, 895, 894, 893, 752,
  751, 728, 728, 728, 729, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
  781, 781, 781, 781, 781, 781, 782, 782, 782, 782, 782, 782, 782, 782, 781, 781, 781, 781, 781,
  752, 749, 749, 892, 749, 749, 946, 946, 890, 946, 946, 889, 956, 956, 750, 956, 956, 946, 946,
  888, 946, 946, 887, 902,

  781, 781, 781, 781, 200, 886, 885, 884, 883, 947, 882, 881, 880, 879, 878, 957, 877, 876, 874,
  871, 947, 870, 686, 869, 751, 868, 686, 867, 866, 865, 781, 781, 781, 782, 787, 787, 787, 787,
  787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 788, 788, 788,
  788, 788, 788, 788, 788, 787, 787, 787, 787, 787, 862, 956, 956, 861, 956, 956, 969, 969, 860,
  969, 969, 969, 969, 859, 969, 969, 858, 857, 856, 855, 854, 853, 852, 851, 787, 787, 787, 787,
  957, 850, 849, 848, 847,

  970, 846, 845, 844, 843, 970, 842, 840, 839, 838, 837, 836, 835, 686, 834, 833, 832, 831, 686,
  830, 829, 787, 787, 787, 788, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796,
  796, 796, 796, 796, 796, 796, 796, 797, 797, 797, 797, 797, 797, 797, 797, 796, 796, 796, 796,
  796, 828, 678, 678, 200, 819, 818, 817, 816, 815, 814, 813, 812, 811, 810, 809, 808, 807, 806,
  805, 804, 803, 802, 801, 800, 796, 796, 796, 796, 793, 792, 790, 786, 785, 784, 783, 780, 779,
  778, 777, 776, 775, 774,

  773, 772, 771, 770, 769, 768, 767, 766, 765, 764, 763, 762, 796, 796, 796, 797, 872, 872, 872,
  872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 873, 873,
  873, 873, 873, 873, 873, 873, 872, 872, 872, 872, 872, 761, 760, 759, 758, 757, 746, 745, 744,
  743, 742, 741, 740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 730, 724, 723, 872, 872, 872,
  872, 722, 721, 720, 717, 716, 715, 713, 712, 711, 710, 709, 708, 707, 706, 705, 704, 703, 702,
  701, 700, 699, 698, 697,

  696, 695, 694, 872, 872, 872, 873, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 75, 75,
  75, 75, 75, 75, 693, 75, 75, 75, 75, 75, 75, 75, 81, 81, 692, 81, 81, 691, 690, 689, 688, 687, 81,
  81, 81, 106, 106, 106, 106, 686, 106, 106, 106, 117, 117, 685, 117, 117, 117, 191, 191, 684, 191,
  191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 196, 196, 196, 199, 199, 199, 199, 199, 199,
  209, 683, 209, 209, 682, 209, 209, 209, 212, 212, 681, 212, 212, 212, 212,

  212, 212, 212, 212, 212, 212, 212, 215, 215, 680, 215, 215, 215, 217, 217, 217, 217, 679, 217,
  217, 217, 223, 223, 678, 223, 224, 224, 677, 224, 224, 224, 232, 676, 675, 665, 232, 232, 232,
  232, 232, 232, 232, 232, 232, 232, 312, 312, 664, 312, 312, 312, 312, 312, 312, 312, 312, 312,
  312, 312, 318, 318, 663, 318, 318, 318, 320, 320, 320, 329, 329, 662, 329, 329, 329, 336, 661,
  336, 336, 658, 336, 336, 336, 338, 338, 655, 338, 338, 338, 341, 341, 654, 341, 341, 341, 345,
  653, 345, 652, 651, 345,

  345, 345, 348, 650, 348, 348, 649, 348, 348, 348, 352, 648, 352, 352, 647, 352, 352, 352, 354,
  646, 354, 354, 645, 354, 354, 354, 436, 436, 644, 436, 436, 436, 436, 436, 436, 436, 436, 436,
  436, 436, 442, 442, 639, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 448, 448, 638,
  448, 448, 448, 81, 637, 636, 635, 634, 633, 81, 81, 81, 199, 199, 199, 199, 199, 199, 460, 632,
  460, 460, 631, 460, 460, 460, 461, 461, 630, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461,
  461, 336, 629, 336,

  336, 628, 336, 336, 336, 462, 462, 627, 462, 462, 462, 338, 338, 626, 338, 338, 338, 468, 625,
  468, 468, 624, 468, 468, 468, 341, 341, 623, 341, 341, 341, 470, 622, 470, 470, 621, 470, 470,
  470, 345, 620, 345, 619, 618, 345, 345, 345, 471, 471, 617, 471, 471, 471, 348, 616, 348, 348,
  615, 348, 348, 348, 472, 472, 614, 472, 472, 472, 350, 350, 613, 350, 352, 610, 352, 352, 609,
  352, 352, 352, 475, 608, 475, 475, 607, 475, 475, 475, 476, 476, 606, 476, 476, 476, 354, 605,
  354, 354, 604, 354, 354,

  354, 477, 477, 603, 477, 477, 477, 117, 117, 602, 117, 117, 117, 481, 481, 481, 436, 436, 601,
  436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 558, 558, 600, 558, 558, 558, 558, 558,
  558, 558, 558, 558, 558, 558, 312, 312, 599, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
  312, 442, 442, 598, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 564, 564, 597, 564,
  564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 565, 565, 596, 565, 565, 565, 565, 565, 565,
  565, 565, 565, 565, 565,

  566, 566, 595, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 448, 448, 594, 448, 448,
  448, 199, 199, 199, 199, 199, 199, 209, 593, 209, 209, 592, 209, 209, 209, 460, 591, 460, 460,
  590, 460, 460, 460, 329, 329, 589, 329, 329, 329, 461, 461, 588, 461, 461, 461, 461, 461, 461,
  461, 461, 461, 461, 461, 462, 462, 586, 462, 462, 462, 581, 585, 581, 581, 584, 581, 581, 581,
  215, 568, 215, 215, 567, 215, 215, 215, 468, 563, 468, 468, 555, 468, 468, 468, 338, 338, 554,
  338, 338, 338, 470, 553,

  470, 470, 552, 470, 470, 470, 583, 583, 551, 583, 583, 583, 471, 471, 550, 471, 471, 471, 472,
  472, 549, 472, 472, 472, 475, 548, 475, 475, 545, 475, 475, 475, 476, 476, 544, 476, 476, 476,
  477, 477, 543, 477, 477, 477, 117, 117, 542, 117, 117, 117, 587, 587, 541, 587, 587, 587, 436,
  436, 540, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 558, 558, 539, 558, 558, 558,
  558, 558, 558, 558, 558, 558, 558, 558, 659, 659, 538, 659, 659, 659, 659, 659, 659, 659, 659,
  659, 659, 659, 660, 660,

  537, 660, 660, 660, 660, 660, 660, 660, 660, 660, 660, 660, 312, 312, 534, 312, 312, 312, 312,
  312, 312, 312, 312, 312, 312, 312, 564, 564, 533, 564, 564, 564, 564, 564, 564, 564, 564, 564,
  564, 564, 565, 565, 532, 565, 565, 565, 565, 565, 565, 565, 565, 565, 565, 565, 566, 566, 531,
  566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 199, 199, 199, 199, 199, 199, 209, 530,
  209, 209, 529, 209, 209, 209, 336, 528, 336, 336, 527, 336, 336, 336, 581, 526, 581, 581, 525,
  581, 581, 581, 462, 462,

  524, 462, 462, 462, 215, 523, 215, 215, 522, 215, 215, 215, 583, 583, 521, 583, 583, 583, 891,
  891, 520, 891, 891, 891, 891, 891, 891, 891, 891, 891, 891, 891, 915, 915, 519, 915, 915, 915,
  915, 915, 915, 915, 915, 915, 915, 915, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718,
  518, 517, 718, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 728, 516, 515, 728, 781, 781,
  781, 781, 781, 781, 781, 781, 781, 781, 781, 514, 513, 781, 787, 787, 787, 787, 787, 787, 787,
  787, 787, 787, 787, 512,

  511, 787, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 510, 509, 796, 953, 953, 508,
  953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 961, 961, 507, 961, 961, 961, 961, 961,
  961, 961, 961, 961, 961, 961, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 504, 503,
  872, 973, 973, 502, 973, 973, 973, 973, 973, 973, 973, 973, 973, 973, 973, 974, 974, 501, 974,
  974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 500, 499, 498, 497, 496, 495, 494, 493, 492,
  491, 490, 489, 488, 487,

  486, 485, 484, 483, 482, 480, 479, 478, 447, 446, 443, 332, 434, 433, 432, 431, 430, 429, 428,
  427, 426, 425, 422, 419, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406, 405,
  404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386,
  385, 384, 383, 382, 379, 378, 377, 376, 375, 374, 373, 372, 369, 366, 365, 364, 363, 362, 361,
  360, 359, 233, 358, 357, 356, 355, 333, 332, 321, 200, 192, 195, 192, 307, 306, 305, 302, 301,
  298, 297, 296, 295, 291,

  288, 285, 282, 281, 280, 279, 276, 275, 274, 273, 272, 269, 268, 265, 264, 263, 257, 256, 255,
  254, 253, 252, 251, 250, 240, 239, 238, 237, 129, 234, 233, 231, 230, 125, 76, 229, 228, 227, 226,
  206, 205, 200, 197, 195, 192, 183, 182, 167, 157, 156, 131, 126, 125, 119, 118, 114, 85, 76, 66,
  975, 3, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975,

  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975 };

static const flex_int16_t yy_chk[2853] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 2, 2, 5, 2, 2, 9, 5, 2, 10,

  11, 10, 10, 13, 13, 17, 13, 13, 16, 2, 19, 22, 13, 890, 22, 19, 13, 30, 17, 17, 11, 18, 2, 16, 23,
  18, 19, 18, 18, 18, 18, 18, 18, 18, 18, 13, 30, 13, 29, 21, 25, 25, 29, 23, 23, 23, 21, 9, 21, 21,
  21, 21, 21, 21, 21, 21, 13, 32, 35, 76, 35, 32, 43, 13, 20, 21, 34, 34, 76, 34, 34, 20, 43, 20,
  20, 20, 20, 20, 20, 20, 20, 29, 38, 39, 40, 39, 41, 20, 38, 40, 20, 58, 39, 41, 21, 38, 41, 38,
  42, 41,

  32, 38, 49, 44, 49, 49, 45, 42, 20, 44, 38, 45, 50, 67, 48, 50, 20, 42, 48, 20, 52, 52, 34, 53,
  54, 75, 53, 48, 54, 55, 52, 52, 892, 48, 55, 53, 63, 20, 80, 55, 83, 63, 53, 54, 59, 59, 65, 59,
  59, 58, 65, 59, 63, 83, 84, 94, 77, 77, 80, 77, 77, 82, 59, 94, 67, 77, 82, 54, 93, 77, 101, 101,
  75, 95, 167, 59, 167, 93, 93, 93, 93, 93, 93, 93, 93, 120, 95, 84, 77, 893, 77, 54, 146, 146, 93,
  202, 54, 97, 97, 97,

  97, 97, 97, 97, 97, 132, 154, 147, 151, 77, 147, 202, 151, 132, 154, 147, 77, 169, 127, 127, 160,
  127, 127, 93, 98, 98, 98, 98, 98, 98, 98, 98, 165, 99, 160, 169, 120, 165, 195, 195, 99, 98, 99,
  99, 99, 99, 99, 99, 99, 99, 242, 100, 171, 203, 180, 171, 180, 242, 100, 99, 100, 100, 100, 100,
  100, 100, 100, 100, 171, 327, 98, 203, 176, 102, 127, 102, 176, 100, 102, 102, 102, 102, 102, 102,
  102, 102, 201, 244, 99, 104, 104, 104, 104, 104, 104, 104, 104, 189, 105, 201,

  244, 894, 189, 253, 310, 105, 100, 105, 105, 105, 105, 105, 105, 105, 105, 176, 253, 192, 197,
  192, 107, 327, 107, 197, 105, 107, 107, 107, 107, 107, 107, 107, 107, 137, 177, 137, 137, 193,
  137, 204, 315, 137, 315, 177, 308, 193, 326, 137, 294, 137, 137, 137, 308, 105, 186, 186, 896,
  186, 186, 294, 310, 186, 194, 194, 207, 207, 207, 207, 207, 207, 207, 207, 186, 192, 197, 204,
  194, 220, 204, 296, 326, 451, 313, 208, 319, 186, 220, 220, 296, 194, 204, 204, 208, 208, 208,
  208, 208, 208, 208, 208,

  313, 451, 321, 324, 897, 210, 321, 210, 324, 208, 210, 210, 210, 210, 210, 210, 210, 210, 214,
  219, 219, 219, 219, 219, 219, 219, 219, 214, 214, 214, 214, 214, 214, 214, 214, 319, 343, 343,
  208, 384, 216, 384, 216, 898, 214, 216, 216, 216, 216, 216, 216, 216, 216, 218, 437, 218, 309,
  309, 218, 218, 218, 218, 218, 218, 218, 218, 454, 415, 323, 453, 309, 415, 437, 214, 221, 221,
  221, 221, 221, 221, 221, 221, 222, 309, 323, 439, 449, 439, 721, 899, 721, 222, 222, 222, 222,
  222, 222, 222, 222, 223,

  325, 328, 455, 452, 449, 748, 456, 322, 223, 223, 223, 223, 223, 223, 223, 223, 322, 454, 225,
  453, 748, 223, 223, 223, 223, 223, 223, 225, 225, 225, 225, 225, 225, 225, 225, 440, 344, 325,
  425, 455, 440, 452, 328, 450, 325, 344, 344, 425, 456, 450, 223, 223, 223, 223, 223, 223, 330,
  330, 330, 330, 330, 330, 330, 330, 331, 334, 334, 334, 334, 334, 334, 334, 334, 331, 331, 331,
  331, 331, 331, 331, 331, 335, 339, 339, 339, 339, 339, 339, 339, 339, 335, 335, 335, 335, 335,
  335, 335, 335, 900, 509,

  901, 556, 572, 337, 509, 337, 556, 335, 337, 337, 337, 337, 337, 337, 337, 337, 340, 346, 346,
  346, 346, 346, 346, 346, 346, 340, 340, 340, 340, 340, 340, 340, 340, 342, 570, 669, 335, 902,
  572, 570, 573, 347, 342, 342, 342, 342, 342, 342, 342, 342, 347, 347, 347, 347, 347, 347, 347,
  347, 350, 458, 458, 458, 458, 458, 458, 458, 458, 350, 350, 350, 350, 350, 350, 350, 350, 747,
  573, 353, 569, 669, 350, 350, 350, 350, 350, 350, 353, 353, 353, 353, 353, 353, 353, 353, 463,
  463, 463, 463, 463, 463,

  463, 463, 569, 747, 903, 904, 905, 457, 574, 350, 350, 350, 350, 350, 350, 351, 457, 457, 457,
  457, 457, 457, 457, 457, 351, 351, 351, 351, 351, 351, 351, 351, 576, 907, 459, 908, 909, 351,
  351, 351, 351, 351, 351, 459, 459, 459, 459, 459, 459, 459, 459, 466, 466, 466, 466, 466, 466,
  466, 466, 666, 574, 632, 632, 464, 632, 632, 351, 351, 351, 351, 351, 351, 464, 464, 464, 464,
  464, 464, 464, 464, 465, 666, 753, 576, 911, 755, 913, 914, 467, 465, 465, 465, 465, 465, 465,
  465, 465, 467, 467, 467,

  467, 467, 467, 467, 467, 469, 575, 670, 824, 672, 571, 916, 825, 826, 469, 469, 469, 469, 469,
  469, 469, 469, 473, 571, 712, 712, 753, 712, 712, 755, 643, 473, 473, 473, 473, 473, 473, 473,
  473, 643, 643, 670, 575, 672, 473, 473, 473, 473, 473, 473, 540, 577, 824, 917, 540, 540, 825,
  826, 918, 540, 577, 577, 577, 577, 577, 577, 577, 577, 919, 920, 921, 578, 922, 473, 473, 473,
  473, 473, 473, 474, 578, 578, 578, 578, 578, 578, 578, 578, 474, 474, 474, 474, 474, 474, 474,
  474, 717, 717, 923, 717,

  717, 474, 474, 474, 474, 474, 474, 579, 579, 579, 579, 579, 579, 579, 579, 667, 671, 754, 926,
  927, 929, 930, 667, 717, 932, 714, 714, 580, 714, 714, 474, 474, 474, 474, 474, 474, 580, 580,
  580, 580, 580, 580, 580, 580, 582, 842, 842, 937, 842, 842, 938, 754, 671, 582, 582, 582, 582,
  582, 582, 582, 582, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637,
  637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 673,
  668, 668, 756, 668, 668,

  674, 794, 794, 714, 794, 794, 940, 941, 668, 674, 674, 674, 674, 674, 674, 674, 674, 945, 637,
  637, 637, 637, 668, 749, 749, 948, 749, 749, 794, 950, 673, 756, 952, 954, 955, 958, 749, 789,
  789, 959, 789, 789, 668, 962, 827, 963, 964, 966, 637, 637, 637, 637, 644, 644, 644, 644, 644,
  644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644, 644,
  644, 644, 644, 644, 644, 644, 644, 644, 644, 967, 752, 752, 827, 752, 752, 820, 820, 863, 820,
  820, 889, 887, 886, 752,

  885, 884, 883, 882, 820, 881, 880, 879, 878, 644, 644, 644, 644, 752, 877, 789, 822, 822, 820,
  822, 822, 875, 875, 876, 875, 875, 874, 871, 869, 822, 868, 866, 864, 865, 862, 861, 860, 863,
  820, 644, 644, 644, 644, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705,
  705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705,
  864, 821, 821, 859, 821, 821, 928, 928, 857, 928, 928, 856, 944, 944, 821, 944, 944, 946, 946,
  855, 946, 946, 854, 875,

  705, 705, 705, 705, 821, 853, 852, 851, 850, 928, 849, 848, 847, 846, 845, 944, 844, 843, 841,
  838, 946, 836, 835, 834, 821, 833, 832, 831, 830, 829, 705, 705, 705, 705, 711, 711, 711, 711,
  711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711,
  711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 819, 956, 956, 818, 956, 956, 965, 965, 817,
  965, 965, 969, 969, 816, 969, 969, 815, 814, 813, 812, 811, 807, 805, 804, 711, 711, 711, 711,
  956, 803, 802, 801, 800,

  965, 799, 798, 793, 791, 969, 790, 785, 783, 779, 777, 776, 773, 772, 771, 768, 767, 766, 765,
  764, 763, 711, 711, 711, 711, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720,
  720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720, 720,
  720, 762, 758, 757, 751, 746, 745, 744, 743, 742, 741, 740, 739, 737, 736, 734, 733, 731, 730,
  727, 726, 725, 724, 723, 722, 720, 720, 720, 720, 716, 715, 713, 710, 709, 708, 707, 704, 703,
  701, 700, 699, 698, 697,

  695, 694, 693, 692, 691, 690, 689, 688, 687, 685, 684, 682, 720, 720, 720, 720, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 681, 679, 677, 676, 675, 665, 664, 663,
  662, 661, 658, 657, 656, 654, 653, 652, 651, 650, 649, 648, 647, 646, 642, 641, 840, 840, 840,
  840, 640, 639, 638, 635, 634, 633, 631, 630, 629, 628, 627, 625, 624, 623, 622, 618, 617, 614,
  613, 612, 611, 610, 609,

  606, 605, 604, 840, 840, 840, 840, 976, 976, 976, 976, 976, 976, 976, 976, 976, 976, 976, 976,
  976, 976, 977, 977, 977, 977, 977, 977, 603, 977, 977, 977, 977, 977, 977, 977, 978, 978, 602,
  978, 978, 601, 600, 599, 598, 597, 978, 978, 978, 979, 979, 979, 979, 596, 979, 979, 979, 980,
  980, 595, 980, 980, 980, 981, 981, 594, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
  982, 982, 982, 983, 983, 983, 983, 983, 983, 984, 593, 984, 984, 592, 984, 984, 984, 985, 985,
  591, 985, 985, 985, 985,

  985, 985, 985, 985, 985, 985, 985, 986, 986, 590, 986, 986, 986, 987, 987, 987, 987, 589, 987,
  987, 987, 988, 988, 588, 988, 989, 989, 586, 989, 989, 989, 990, 585, 584, 568, 990, 990, 990,
  990, 990, 990, 990, 990, 990, 990, 991, 991, 567, 991, 991, 991, 991, 991, 991, 991, 991, 991,
  991, 991, 992, 992, 563, 992, 992, 992, 993, 993, 993, 994, 994, 562, 994, 994, 994, 995, 561,
  995, 995, 557, 995, 995, 995, 996, 996, 555, 996, 996, 996, 997, 997, 554, 997, 997, 997, 998,
  553, 998, 552, 551, 998,

  998, 998, 999, 549, 999, 999, 547, 999, 999, 999, 1000, 546, 1000, 1000, 544, 1000, 1000, 1000,
  1001, 543, 1001, 1001, 542, 1001, 1001, 1001, 1002, 1002, 541, 1002, 1002, 1002, 1002, 1002, 1002,
  1002, 1002, 1002, 1002, 1002, 1003, 1003, 539, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003,
  1003, 1003, 1003, 1004, 1004, 538, 1004, 1004, 1004, 1005, 537, 536, 535, 533, 532, 1005, 1005,
  1005, 1006, 1006, 1006, 1006, 1006, 1006, 1007, 531, 1007, 1007, 530, 1007, 1007, 1007, 1008,
  1008, 529, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1009, 528, 1009,

  1009, 526, 1009, 1009, 1009, 1010, 1010, 525, 1010, 1010, 1010, 1011, 1011, 524, 1011, 1011, 1011,
  1012, 523, 1012, 1012, 522, 1012, 1012, 1012, 1013, 1013, 521, 1013, 1013, 1013, 1014, 520, 1014,
  1014, 519, 1014, 1014, 1014, 1015, 518, 1015, 516, 515, 1015, 1015, 1015, 1016, 1016, 514, 1016,
  1016, 1016, 1017, 513, 1017, 1017, 512, 1017, 1017, 1017, 1018, 1018, 511, 1018, 1018, 1018, 1019,
  1019, 510, 1019, 1020, 506, 1020, 1020, 505, 1020, 1020, 1020, 1021, 502, 1021, 1021, 501, 1021,
  1021, 1021, 1022, 1022, 500, 1022, 1022, 1022, 1023, 499, 1023, 1023, 498, 1023, 1023,

  1023, 1024, 1024, 497, 1024, 1024, 1024, 1025, 1025, 496, 1025, 1025, 1025, 1026, 1026, 1026,
  1027, 1027, 495, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1028, 1028,
  494, 1028, 1028, 1028, 1028, 1028, 1028, 1028, 1028, 1028, 1028, 1028, 1029, 1029, 493, 1029,
  1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1030, 1030, 492, 1030, 1030, 1030,
  1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1031, 1031, 491, 1031, 1031, 1031, 1031, 1031,
  1031, 1031, 1031, 1031, 1031, 1031, 1032, 1032, 490, 1032, 1032, 1032, 1032, 1032, 1032, 1032,
  1032, 1032, 1032, 1032,

  1033, 1033, 489, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1034, 1034,
  488, 1034, 1034, 1034, 1035, 1035, 1035, 1035, 1035, 1035, 1036, 487, 1036, 1036, 486, 1036, 1036,
  1036, 1037, 485, 1037, 1037, 484, 1037, 1037, 1037, 1038, 1038, 483, 1038, 1038, 1038, 1039, 1039,
  482, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1040, 1040, 480, 1040,
  1040, 1040, 1041, 479, 1041, 1041, 478, 1041, 1041, 1041, 1042, 447, 1042, 1042, 446, 1042, 1042,
  1042, 1043, 441, 1043, 1043, 434, 1043, 1043, 1043, 1044, 1044, 433, 1044, 1044, 1044, 1045, 432,

  1045, 1045, 431, 1045, 1045, 1045, 1046, 1046, 429, 1046, 1046, 1046, 1047, 1047, 428, 1047, 1047,
  1047, 1048, 1048, 427, 1048, 1048, 1048, 1049, 426, 1049, 1049, 424, 1049, 1049, 1049, 1050, 1050,
  423, 1050, 1050, 1050, 1051, 1051, 422, 1051, 1051, 1051, 1052, 1052, 421, 1052, 1052, 1052, 1053,
  1053, 420, 1053, 1053, 1053, 1054, 1054, 419, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054,
  1054, 1054, 1054, 1055, 1055, 418, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055,
  1055, 1056, 1056, 417, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1057,
  1057,

  416, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1058, 1058, 414, 1058,
  1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1059, 1059, 413, 1059, 1059, 1059,
  1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1060, 1060, 412, 1060, 1060, 1060, 1060, 1060,
  1060, 1060, 1060, 1060, 1060, 1060, 1061, 1061, 411, 1061, 1061, 1061, 1061, 1061, 1061, 1061,
  1061, 1061, 1061, 1061, 1062, 1062, 1062, 1062, 1062, 1062, 1063, 410, 1063, 1063, 409, 1063,
  1063, 1063, 1064, 408, 1064, 1064, 407, 1064, 1064, 1064, 1065, 406, 1065, 1065, 405, 1065, 1065,
  1065, 1066, 1066,

  404, 1066, 1066, 1066, 1067, 403, 1067, 1067, 402, 1067, 1067, 1067, 1068, 1068, 401, 1068, 1068,
  1068, 1069, 1069, 399, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1070,
  1070, 398, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1071, 1071, 1071,
  1071, 1071, 1071, 1071, 1071, 1071, 1071, 1071, 397, 396, 1071, 1072, 1072, 1072, 1072, 1072,
  1072, 1072, 1072, 1072, 1072, 1072, 395, 394, 1072, 1073, 1073, 1073, 1073, 1073, 1073, 1073,
  1073, 1073, 1073, 1073, 392, 391, 1073, 1074, 1074, 1074, 1074, 1074, 1074, 1074, 1074, 1074,
  1074, 1074, 390,

  389, 1074, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 388, 387, 1075, 1076,
  1076, 386, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1077, 1077, 385,
  1077, 1077, 1077, 1077, 1077, 1077, 1077, 1077, 1077, 1077, 1077, 1078, 1078, 1078, 1078, 1078,
  1078, 1078, 1078, 1078, 1078, 1078, 383, 381, 1078, 1079, 1079, 380, 1079, 1079, 1079, 1079, 1079,
  1079, 1079, 1079, 1079, 1079, 1079, 1080, 1080, 378, 1080, 1080, 1080, 1080, 1080, 1080, 1080,
  1080, 1080, 1080, 1080, 377, 376, 375, 374, 373, 372, 371, 370, 369, 368, 367, 366, 365, 364,

  363, 362, 361, 360, 359, 357, 356, 355, 317, 316, 314, 311, 307, 306, 305, 304, 303, 302, 301,
  300, 299, 298, 295, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279,
  278, 277, 275, 274, 273, 272, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258,
  257, 256, 255, 254, 252, 251, 250, 249, 248, 247, 246, 245, 243, 241, 240, 239, 238, 237, 236,
  235, 234, 232, 231, 230, 229, 228, 213, 211, 200, 199, 191, 190, 188, 183, 182, 181, 179, 178,
  175, 174, 173, 172, 170,

  168, 166, 164, 163, 162, 161, 159, 158, 157, 156, 155, 153, 152, 150, 149, 148, 145, 144, 143,
  142, 141, 140, 139, 138, 136, 135, 134, 133, 130, 126, 125, 124, 123, 122, 121, 119, 118, 116,
  112, 92, 90, 81, 69, 64, 62, 57, 56, 51, 47, 46, 37, 33, 31, 28, 26, 24, 15, 12, 8, 3, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,

  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975 };

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[168] = {
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;

/*

This file must be translated to C and modified to build everywhere.

See the adjacent README.txt file for instructions.

*/

/* to workaround https://bugs.llvm.org/show_bug.cgi?id=43465 */
#if defined(__clang__)
#pragma clang diagnostic push
#if defined(__has_warning)
#if __has_warning("-Wimplicit-fallthrough")
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#endif
#endif
#elif defined(__GNUC__) && (__GNUC__ >= 7)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#endif

/* We do not care of interactive mode */
#define YY_NEVER_INTERACTIVE 1

/* Do not include unistd.h in generated source. */
#define YY_NO_UNISTD_H

/* Skip declaring this function.  It is a macro.  */
#define YY_SKIP_YYWRAP

#ifdef _WIN32
#pragma warning(disable : 4018)
#pragma warning(disable : 4127)
#pragma warning(disable : 4131)
#pragma warning(disable : 4244)
#pragma warning(disable : 4251)
#pragma warning(disable : 4267)
#pragma warning(disable : 4305)
#pragma warning(disable : 4309)
#pragma warning(disable : 4706)
#pragma warning(disable : 4786)
#endif

#define SKIP_MATCH_MAXLEN 15

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 * Return 0 if no match found.
 */
static int skip_comment(void);
static int skip_trailing_comment(const char* text, size_t l);
static int skip_ahead_multi(const char* strings[]);
static int skip_ahead_until(const char* text);
static int skip_to_next_directive(void);
static int skip_conditional_block(void);

static void doxygen_comment(void);
static void doxygen_cpp_comment(void);
static void doxygen_group_start(void);
static void doxygen_group_end(void);
static void vtk_comment(void);
static void vtk_name_comment(void);
static void vtk_section_comment(void);
static void cpp_comment_line(void);
static void blank_line(void);

static const char* raw_string(const char* begin, int* has_ud_suffix);

static void preprocessor_directive(const char* text, size_t l);
static void print_preprocessor_error(int result, const char* cp, size_t n);
static char* get_macro_arguments(void);
static void skip_macro_arguments(void);

static void push_buffer(void);
static int pop_buffer(void);

static void push_include(const char* filename);
static void pop_include(void);

static void push_macro(MacroInfo* macro);
static void pop_macro(void);
static int in_macro(void);

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void*
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE* yyget_in(void);

void yyset_in(FILE* _in_str);

FILE* yyget_out(void);

void yyset_out(FILE* _out_str);

int yyget_leng(void);

char* yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* buf_ptr);

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char*, const char*, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char*);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                                       \
  do                                                                                               \
  {                                                                                                \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout))                                                  \
    {                                                                                              \
    }                                                                                              \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                                 \
  {                                                                                                \
    int c = '*';                                                                                   \
    int n;                                                                                         \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                         \
      buf[n] = (char)c;                                                                            \
    if (c == '\n')                                                                                 \
      buf[n++] = (char)c;                                                                          \
    if (c == EOF && ferror(yyin))                                                                  \
      YY_FATAL_ERROR("input in flex scanner failed");                                              \
    result = n;                                                                                    \
  }                                                                                                \
  else                                                                                             \
  {                                                                                                \
    errno = 0;                                                                                     \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin))          \
    {                                                                                              \
      if (errno != EINTR)                                                                          \
      {                                                                                            \
        YY_FATAL_ERROR("input in flex scanner failed");                                            \
        break;                                                                                     \
      }                                                                                            \
      errno = 0;                                                                                   \
      clearerr(yyin);                                                                              \
    }                                                                                              \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP                                                                              \
  if (yyleng > 0)                                                                                  \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (yytext[yyleng - 1] == '\n');                            \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

  if (!(yy_init))
  {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      yyin = stdin;

    if (!yyout)
      yyout = stdout;

    if (!YY_CURRENT_BUFFER)
    {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {

    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
      yy_current_state += YY_AT_BOL();
    yy_match:
      do
      {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state])
        {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 976)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 2761);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0)
      { /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
      {
        int yyl;
        for (yyl = 0; yyl < yyleng; ++yyl)
          if (yytext[yyl] == '\n')

            yylineno++;
        ;
      }

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act)
      {         /* beginning of action switch */
        case 0: /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          YY_RULE_SETUP
          {
            doxygen_comment();
          }
          YY_BREAK
        case 2:
          YY_RULE_SETUP
          {
            doxygen_comment();
          }
          YY_BREAK
        case 3:
          YY_RULE_SETUP
          {
            skip_comment();
          }
          YY_BREAK
        case 4:
          YY_RULE_SETUP
          {
            skip_ahead_until("@end");
          }
          YY_BREAK
        case 5:
          YY_RULE_SETUP
          {
            doxygen_cpp_comment();
          }
          YY_BREAK
        case 6:
          YY_RULE_SETUP
          {
            doxygen_cpp_comment();
          }
          YY_BREAK
        case 7:
          YY_RULE_SETUP
          {
            doxygen_group_start();
          }
          YY_BREAK
        case 8:
          YY_RULE_SETUP
          {
            doxygen_group_end();
          }
          YY_BREAK
        case 9:
          YY_RULE_SETUP
          {
            vtk_comment();
          }
          YY_BREAK
        case 10:
          YY_RULE_SETUP
          {
            vtk_name_comment();
          }
          YY_BREAK
        case 11:
          YY_RULE_SETUP
          {
            vtk_section_comment();
          }
          YY_BREAK
        case 12:
          YY_RULE_SETUP
          {
            cpp_comment_line();
          }
          YY_BREAK
        case 13:
          /* rule 13 can match eol */
          YY_RULE_SETUP
          {
            blank_line();
          }
          YY_BREAK
        case 14:
          YY_RULE_SETUP
          /* eat trailing C++ comments */
          YY_BREAK
        case 15:
          /* rule 15 can match eol */
          YY_RULE_SETUP
          {
            skip_trailing_comment(yytext, yyleng);
            preprocessor_directive(yytext, yyleng);
          }
          YY_BREAK
        case 16:
          /* rule 16 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 17:
          /* rule 17 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL_UD);
          }
          YY_BREAK
        case 18:
          /* rule 18 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (CHAR_LITERAL);
          }
          YY_BREAK
        case 19:
          YY_RULE_SETUP
          {
            int has_ud_suffix = 0;
            yylval.str = raw_string(yytext, &has_ud_suffix);
            return (has_ud_suffix ? STRING_LITERAL_UD : STRING_LITERAL);
          }
          YY_BREAK
        case 20:
          YY_RULE_SETUP
          return (AUTO);
          YY_BREAK
        case 21:
          YY_RULE_SETUP
          return (DOUBLE);
          YY_BREAK
        case 22:
          YY_RULE_SETUP
          return (FLOAT);
          YY_BREAK
        case 23:
          YY_RULE_SETUP
          return (SHORT);
          YY_BREAK
        case 24:
          YY_RULE_SETUP
          return (LONG);
          YY_BREAK
        case 25:
          YY_RULE_SETUP
          return (CHAR);
          YY_BREAK
        case 26:
          YY_RULE_SETUP
          return (INT);
          YY_BREAK
        case 27:
          YY_RULE_SETUP
          return (UNSIGNED);
          YY_BREAK
        case 28:
          YY_RULE_SETUP
          return (SIGNED);
          YY_BREAK
        case 29:
          YY_RULE_SETUP
          return (VOID);
          YY_BREAK
        case 30:
          YY_RULE_SETUP
          return (BOOL);
          YY_BREAK
        case 31:
          YY_RULE_SETUP
          return (CHAR16_T);
          YY_BREAK
        case 32:
          YY_RULE_SETUP
          return (CHAR32_T);
          YY_BREAK
        case 33:
          YY_RULE_SETUP
          return (WCHAR_T);
          YY_BREAK
        case 34:
          /* rule 34 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::size_t" : "size_t");
            return (SIZE_T);
          }
          YY_BREAK
        case 35:
          /* rule 35 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::ssize_t" : "ssize_t");
            return (SSIZE_T);
          }
          YY_BREAK
        case 36:
          /* rule 36 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::nullptr_t" : "nullptr_t");
            return (NULLPTR_T);
          }
          YY_BREAK
        case 37:
          YY_RULE_SETUP
          /* ignore the Q_OBJECT macro from Qt */
          YY_BREAK
        case 38:
          /* rule 38 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 39:
          /* rule 39 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 40:
          /* rule 40 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 41:
          /* rule 41 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 42:
          YY_RULE_SETUP
          return (CLASS);
          YY_BREAK
        case 43:
          YY_RULE_SETUP
          return (STRUCT);
          YY_BREAK
        case 44:
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 45:
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 46:
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 47:
          YY_RULE_SETUP
          return (ENUM);
          YY_BREAK
        case 48:
          YY_RULE_SETUP
          return (UNION);
          YY_BREAK
        case 49:
          YY_RULE_SETUP
          return (VIRTUAL);
          YY_BREAK
        case 50:
          YY_RULE_SETUP
          return (CONST);
          YY_BREAK
        case 51:
          YY_RULE_SETUP
          return (VOLATILE);
          YY_BREAK
        case 52:
          YY_RULE_SETUP
          return (MUTABLE);
          YY_BREAK
        case 53:
          YY_RULE_SETUP
          return (OPERATOR);
          YY_BREAK
        case 54:
          YY_RULE_SETUP
          return (FRIEND);
          YY_BREAK
        case 55:
          YY_RULE_SETUP
          return (INLINE);
          YY_BREAK
        case 56:
          YY_RULE_SETUP
          return (CONSTEXPR);
          YY_BREAK
        case 57:
          YY_RULE_SETUP
          return (STATIC);
          YY_BREAK
        case 58:
          YY_RULE_SETUP
          return (THREAD_LOCAL);
          YY_BREAK
        case 59:
          YY_RULE_SETUP
          return (EXTERN);
          YY_BREAK
        case 60:
          YY_RULE_SETUP
          return (TEMPLATE);
          YY_BREAK
        case 61:
          YY_RULE_SETUP
          return (TYPENAME);
          YY_BREAK
        case 62:
          YY_RULE_SETUP
          return (TYPEDEF);
          YY_BREAK
        case 63:
          YY_RULE_SETUP
          return (NAMESPACE);
          YY_BREAK
        case 64:
          YY_RULE_SETUP
          return (USING);
          YY_BREAK
        case 65:
          YY_RULE_SETUP
          return (NEW);
          YY_BREAK
        case 66:
          YY_RULE_SETUP
          return (DELETE);
          YY_BREAK
        case 67:
          YY_RULE_SETUP
          return (EXPLICIT);
          YY_BREAK
        case 68:
          YY_RULE_SETUP
          return (THROW);
          YY_BREAK
        case 69:
          YY_RULE_SETUP
          return (TRY);
          YY_BREAK
        case 70:
          YY_RULE_SETUP
          return (CATCH);
          YY_BREAK
        case 71:
          YY_RULE_SETUP
          return (NOEXCEPT);
          YY_BREAK
        case 72:
          YY_RULE_SETUP
          return (DECLTYPE);
          YY_BREAK
        case 73:
          YY_RULE_SETUP
          return (DEFAULT);
          YY_BREAK
        case 74:
          YY_RULE_SETUP
          return (STATIC_CAST);
          YY_BREAK
        case 75:
          YY_RULE_SETUP
          return (DYNAMIC_CAST);
          YY_BREAK
        case 76:
          YY_RULE_SETUP
          return (CONST_CAST);
          YY_BREAK
        case 77:
          YY_RULE_SETUP
          return (REINTERPRET_CAST);
          YY_BREAK
        case 78:
          YY_RULE_SETUP
          /* irrelevant to wrappers */
          YY_BREAK
        case 79:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 80:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 81:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 82:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 83:
          YY_RULE_SETUP
          return ('!');
          YY_BREAK
        case 84:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 85:
          YY_RULE_SETUP
          return ('^');
          YY_BREAK
        case 86:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 87:
          YY_RULE_SETUP
          return ('&');
          YY_BREAK
        case 88:
          YY_RULE_SETUP
          return ('|');
          YY_BREAK
        case 89:
          YY_RULE_SETUP
          return ('~');
          YY_BREAK
        case 90:
          /* rule 90 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '&')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LA);
          }
          YY_BREAK
        case 91:
          /* rule 91 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '*')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LP);
          }
          YY_BREAK
        case 92:
          /* rule 92 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 93:
          /* rule 93 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 94:
          /* rule 94 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 95:
          YY_RULE_SETUP
          return ('*');
          YY_BREAK
        case 96:
          YY_RULE_SETUP
          /* misc unused win32 macros */
          YY_BREAK
        case 97:
          /* rule 97 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OSTREAM);
          }
          YY_BREAK
        case 98:
          /* rule 98 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ISTREAM);
          }
          YY_BREAK
        case 99:
          /* rule 99 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 100:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 101:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (QT_ID);
          }
          YY_BREAK
        case 102:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 103:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 104:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 105:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 106:
          YY_RULE_SETUP
          return (THREAD_LOCAL); /* C11 */
          YY_BREAK
        case 107:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 108:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 109:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C99 */
          YY_BREAK
        case 110:
          YY_RULE_SETUP
          skip_macro_arguments(); /* MSVC */
          YY_BREAK
        case 111:
          YY_RULE_SETUP
          skip_macro_arguments(); /* gcc attributes */
          YY_BREAK
        case 112:
          YY_RULE_SETUP
          skip_macro_arguments(); /* icc attributes */
          YY_BREAK
        case 113:
          YY_RULE_SETUP
          skip_macro_arguments(); /* Windows linkage */
          YY_BREAK
        case 114:
          YY_RULE_SETUP
          /* Windows */
          YY_BREAK
        case 115:
          YY_RULE_SETUP
          /* gcc/clang/other extension */
          YY_BREAK
        case 116:
          YY_RULE_SETUP
          /* MSVC extension */
          YY_BREAK
        case 117:
          YY_RULE_SETUP
          return (INLINE); /* MSVC extensions */
          YY_BREAK
        case 118:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (NULLPTR);
          }
          YY_BREAK
        case 119:
          YY_RULE_SETUP
          {
            const char* name = vtkstrndup(yytext, yyleng);
            MacroInfo* macro = vtkParsePreprocess_GetMacro(preprocessor, name);
            int expanded = 0;
            if (macro)
            {
              char* args = NULL;
              const char* emacro = NULL;

              if (macro->IsFunction)
              {
                args = get_macro_arguments();
                if (args)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, args);
                  if (!emacro)
                  {
                    print_preprocessor_error(VTK_PARSE_MACRO_NUMARGS, NULL, 0);
                    exit(1);
                  }
                  free(args);
                }
              }
              else if (macro->Definition && macro->Definition[0])
              {
                /* first see if macro evaluates to a constant value */
                preproc_int_t val;
                int is_unsigned;
                int r;
                macro->IsExcluded = 1;
                r = vtkParsePreprocess_EvaluateExpression(
                  preprocessor, macro->Definition, &val, &is_unsigned);
                macro->IsExcluded = 0;
                /* if it isn't a constant expression, then expand it */
                if (r >= VTK_PARSE_MACRO_UNDEFINED)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, NULL);
                  if (!emacro)
                  {
                    print_preprocessor_error(r, NULL, 0);
                    exit(1);
                  }
                }
              }
              else
              {
                /* macros with no definition expand to nothing */
                expanded = 1;
              }
              if (emacro)
              {
                /* invoke the parser on any expanded macros */
                push_macro(macro);
                push_buffer();
                yy_switch_to_buffer(yy_scan_string(emacro));
                vtkParsePreprocess_FreeMacroExpansion(preprocessor, macro, emacro);
                expanded = 1;
              }
            }
            if (!expanded)
            {
              /* if no macro expansion occurred, return the ID */
              yylval.str = name;
              if (yyleng > 3 && name[0] == 'v' && name[1] == 't' && name[2] == 'k')
              {
                return (VTK_ID);
              }
              else if (name[0] == 'Q')
              {
                return (QT_ID);
              }
              else
              {
                return (ID);
              }
            }
          }
          YY_BREAK
        case 120:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 121:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 122:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 123:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 124:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (HEX_LITERAL);
          }
          YY_BREAK
        case 125:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (BIN_LITERAL);
          }
          YY_BREAK
        case 126:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OCT_LITERAL);
          }
          YY_BREAK
        case 127:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (INT_LITERAL);
          }
          YY_BREAK
        case 128:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ZERO);
          }
          YY_BREAK
        case 129:
          /* rule 129 can match eol */
          YY_RULE_SETUP
          /* escaped newlines */
          YY_BREAK
        case 130:
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 131:
          /* rule 131 can match eol */
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 132:
          /* rule 132 can match eol */
          YY_RULE_SETUP
          return (BEGIN_ATTRIB);
          YY_BREAK
        case 133:
          YY_RULE_SETUP
          return ('{');
          YY_BREAK
        case 134:
          YY_RULE_SETUP
          return ('}');
          YY_BREAK
        case 135:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 136:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 137:
          YY_RULE_SETUP
          return ('#');
          YY_BREAK
        case 138:
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          (yy_c_buf_p) = yy_cp = yy_bp + 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (OP_RSHIFT_A);
          YY_BREAK
        case 139:
          YY_RULE_SETUP
          return (OP_LSHIFT_EQ);
          YY_BREAK
        case 140:
          YY_RULE_SETUP
          return (OP_RSHIFT_EQ);
          YY_BREAK
        case 141:
          YY_RULE_SETUP
          return (OP_LSHIFT);
          YY_BREAK
        case 142:
          YY_RULE_SETUP
          return (OP_DOT_POINTER);
          YY_BREAK
        case 143:
          YY_RULE_SETUP
          return (OP_ARROW_POINTER);
          YY_BREAK
        case 144:
          YY_RULE_SETUP
          return (OP_ARROW);
          YY_BREAK
        case 145:
          YY_RULE_SETUP
          return (OP_INCR);
          YY_BREAK
        case 146:
          YY_RULE_SETUP
          return (OP_DECR);
          YY_BREAK
        case 147:
          YY_RULE_SETUP
          return (OP_PLUS_EQ);
          YY_BREAK
        case 148:
          YY_RULE_SETUP
          return (OP_MINUS_EQ);
          YY_BREAK
        case 149:
          YY_RULE_SETUP
          return (OP_TIMES_EQ);
          YY_BREAK
        case 150:
          YY_RULE_SETUP
          return (OP_DIVIDE_EQ);
          YY_BREAK
        case 151:
          YY_RULE_SETUP
          return (OP_REMAINDER_EQ);
          YY_BREAK
        case 152:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 153:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 154:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 155:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 156:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 157:
          YY_RULE_SETUP
          return (OP_LOGIC_EQ);
          YY_BREAK
        case 158:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 159:
          YY_RULE_SETUP
          return (OP_LOGIC_LEQ);
          YY_BREAK
        case 160:
          YY_RULE_SETUP
          return (OP_LOGIC_GEQ);
          YY_BREAK
        case 161:
          YY_RULE_SETUP
          return (ELLIPSIS);
          YY_BREAK
        case 162:
          YY_RULE_SETUP
          return (DOUBLE_COLON);
          YY_BREAK
        case 163:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 164:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 165:
          YY_RULE_SETUP
          return (yytext[0]);
          YY_BREAK
        case YY_STATE_EOF(INITIAL):
        {
          if (!pop_buffer())
          {
            yyterminate();
          }
        }
          YY_BREAK
        case 166:
          YY_RULE_SETUP
          {
            return (OTHER);
          }
          YY_BREAK
        case 167:
          YY_RULE_SETUP
          YY_FATAL_ERROR("flex scanner jammed");
          YY_BREAK

        case YY_END_OF_BUFFER:
        {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = (yy_hold_char);
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
          {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if ((yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
          { /* This was really a NUL. */
            yy_state_type yy_next_state;

            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state);

            yy_bp = (yytext_ptr) + YY_MORE_ADJ;

            if (yy_next_state)
            {
              /* Consume the NUL. */
              yy_cp = ++(yy_c_buf_p);
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else
            {
              yy_cp = (yy_c_buf_p);
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer())
            {
              case EOB_ACT_END_OF_FILE:
              {
                (yy_did_buffer_switch_on_eof) = 0;

                if (yywrap())
                {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else
                {
                  if (!(yy_did_buffer_switch_on_eof))
                    YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void)
{
  char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char* source = (yytext_ptr);
  int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
  { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1)
    {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else
    {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else
  {
    int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0)
    { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer)
      {
        int new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char*)
          /* Include room in for 2 EOB chars. */
          yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = NULL;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0)
  {
    if (number_to_move == YY_MORE_ADJ)
    {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
  {
    /* Extend the array by 50%, plus the number we really need. */
    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
      (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
    /* "- 2" to take care of EOB's */
    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state;
  char* yy_cp;

  yy_current_state = (yy_start);
  yy_current_state += YY_AT_BOL();

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
  {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state])
    {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 976)
        yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
{
  int yy_is_jam;
  char* yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
  {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
  {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 976)
      yy_c = yy_meta[yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 975);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* yy_bp)
{
  char* yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
  { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = (yy_n_chars) + 2;
    char* dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char* source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
      (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  if (c == '\n')
  {
    --yylineno;
  }

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
  {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else
    { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer())
      {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          yyrestart(yyin);

          /*FALLTHROUGH*/

        case EOB_ACT_END_OF_FILE:
        {
          if (yywrap())
            return 0;

          if (!(yy_did_buffer_switch_on_eof))
            YY_NEW_FILE;
#ifdef __cplusplus
          return yyinput();
#else
          return input();
#endif
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + offset;
          break;
      }
    }
  }

  c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';              /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
  if (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

    yylineno++;
  ;

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE* input_file)
{

  if (!YY_CURRENT_BUFFER)
  {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
{

  /* TODO. We should be able to replace this entire function body
   * with
   *    yypop_buffer_state();
   *    yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void)
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b)
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void*)b->yy_ch_buf);

  yyfree((void*)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER)
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b)
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void)
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER)
  {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack))
  {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    (yy_buffer_stack) =
      (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
  {

    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc(
      (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset(
      (yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
{
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
    base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr)
{

  return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes, int _yybytes_len)
{
  YY_BUFFER_STATE b;
  char* buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char*)yyalloc(n);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char* msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                                      \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p) = '\0';                                                                          \
    yyleng = yyless_macro_arg;                                                                     \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void)
{

  return yylineno;
}

/** Get the input stream.
 *
 */
FILE* yyget_in(void)
{
  return yyin;
}

/** Get the output stream.
 *
 */
FILE* yyget_out(void)
{
  return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
  return yyleng;
}

/** Get the current token.
 *
 */

char* yyget_text(void)
{
  return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{

  yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str)
{
  yyin = _in_str;
}

void yyset_out(FILE* _out_str)
{
  yyout = _out_str;
}

int yyget_debug(void)
{
  return yy_flex_debug;
}

void yyset_debug(int _bdebug)
{
  yy_flex_debug = _bdebug;
}

static int yy_init_globals(void)
{
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from yylex_destroy(), so don't allocate here.
   */

  /* We do not touch yylineno unless the option is enabled. */
  yylineno = 1;

  (yy_buffer_stack) = NULL;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = NULL;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  yyin = stdin;
  yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

  /* For future reference: Set errno on error, since we are called by
   * yylex_init()
   */
  return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER)
  {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state();
  }

  /* Destroy the stack itself. */
  yyfree((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next time
   * yylex() is called, initialization will occur. */
  yy_init_globals();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1, const char* s2, int n)
{

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void* yyalloc(yy_size_t size)
{
  return malloc(size);
}

void* yyrealloc(void* ptr, yy_size_t size)
{

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void* ptr)
{
  free((char*)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/*
 * Return a parenthetical macro arg list as a new string.
 */
char* get_macro_arguments(void)
{
  char* cp = NULL;
  size_t i = 0;
  int depth;
  int ws = 0;
  int sl = 0;
  int c1 = input();

  if (c1 == '\0')
  {
    if (pop_buffer() == 0)
    {
      return NULL;
    }
  }

  while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
  {
    c1 = input();
  }

  cp = (char*)malloc(4);

  if (c1 != '(')
  {
    unput(c1);
    free(cp);
    return NULL;
  }

  cp[i++] = '(';
  depth = 1;
  c1 = input();

  for (;;)
  {
    ws = 0;
    sl = 0;
    /* skip all whitespace */
    while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
    {
      ws = 1;
      c1 = input();
    }
    if (c1 == '/')
    {
      c1 = input();
      if (c1 == '*')
      {
        /* skip a C style comment */
        ws = 1;
        if (skip_comment() == 0)
        {
          return NULL;
        }
        c1 = input();
      }
      else if (c1 == '/')
      {
        /* skip a C++ style comment */
        ws = 1;
        do
        {
          c1 = input();
        } while (c1 != '\n' && c1 != '\0');
        if (c1 == '\0')
        {
          return NULL;
        }
        c1 = input();
      }
      else
      {
        sl = 1;
      }
    }
    if (ws)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = ' ';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (sl)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = '/';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (c1 == '\"' || c1 == '\'')
    {
      int c2 = c1;
      int escaped = 2;
      int firstloop = 1;
      do
      {
        if (escaped)
        {
          --escaped;
        }
        if (!firstloop)
        {
          c1 = input();
        }
        firstloop = 0;
        if (c1 == '\0')
        {
          break;
        }
        if (escaped == 0 && c1 == '\\')
        {
          escaped = 2;
        }
        cp[i++] = (char)c1;
        if (i >= 4 && (i & (i - 1)) == 0)
        {
          char* oldcp = cp;
          cp = (char*)realloc(cp, 2 * i);
          if (!cp)
          {
            free(oldcp);
            return NULL;
          }
        }
      } while (c1 != c2 || escaped);
    }
    else if (c1 != '\0')
    {
      cp[i++] = (char)c1;
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
      cp[i] = '\0';
      if (c1 == '(')
      {
        depth++;
      }
      if (c1 == ')')
      {
        if (--depth == 0)
        {
          break;
        }
      }
    }
    else
    {
      return NULL;
    }
    c1 = input();
  }

  return cp;
}

void skip_macro_arguments(void)
{
  char* p = get_macro_arguments();
  free(p);
}

/*
 * Skip a C-style comment, return 0 if unterminated.
 */
int skip_comment(void)
{
  int savelineno = yylineno;
  int c1 = 0, c2 = input();
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (c1 == '*' && c2 == '/')
      break;
    c1 = c2;
    c2 = input();
  }
  return 1;
}

/*
 * If token contains a comment, make sure whole comment is skipped.
 */
int skip_trailing_comment(const char* text, size_t l)
{
  const char* cp = text;
  const char* ep = text + l;
  int incomment = 0;

  while (cp < ep)
  {
    while (cp < ep && *cp != '/' && *cp != '\"')
    {
      cp++;
    }
    if (cp >= ep)
    {
      break;
    }
    else if (cp[0] == '/' && cp[1] == '*')
    {
      incomment = 1;
      cp += 2;
      while (cp < ep && *cp != '*')
      {
        cp++;
      }
      if (cp[0] == '*' && cp[1] == '/')
      {
        incomment = 0;
        cp += 2;
      }
      else
      {
        cp++;
      }
    }
    else if (cp[0] == '\"')
    {
      cp++;
      while (cp < ep)
      {
        while (cp < ep && *cp != '\\' && *cp != '\"')
        {
          cp++;
        }
        if (cp >= ep)
        {
          break;
        }
        else if (*cp == '\"')
        {
          cp++;
          break;
        }
        else /* if (*cp == '\\') */
        {
          cp += 2;
        }
      }
    }
    else
    {
      cp++;
    }
  }

  if (incomment)
  {
    return skip_comment();
  }

  return 1;
}

/*
 * Skip ahead until the next preprocessor directive.
 * This will eat the '#' that starts the directive.
 * Return 0 if none found.
 */
int skip_to_next_directive(void)
{
  /* state == 0 at the start of a line */
  int state = 0;
  int c;

  c = input();

  while (c != 0 && c != EOF)
  {
    /* whitespace */
    if (c == ' ' || c == '\t')
    {
      c = input();
    }
    /* newline renews the start-of-line state */
    else if (c == '\n')
    {
      state = 0;
      c = input();
    }
    /* skip comments */
    else if (c == '/')
    {
      state = 1;
      if ((c = input()) == '*')
      {
        if (skip_comment() == 0)
        {
          return 0;
        }
        c = input();
      }
    }
    /* skip escaped characters */
    else if (c == '\\')
    {
      state = 1;
      if ((c = input()) == '\r')
      {
        if ((c = input()) == '\n')
        {
          c = input();
        }
      }
      else if (c != 0 && c != EOF)
      {
        c = input();
      }
    }
    /* any other chars except '#' at start of line */
    else if (c != '#' || state != 0)
    {
      state = 1;
      c = input();
    }
    else
    {
      break;
    }
  }

  return c;
}

/*
 * Skip to the next #else or #elif or #endif
 */
int skip_conditional_block(void)
{
  static char* linebuf = NULL;
  static size_t linemaxlen = 80;
  size_t i;
  int c;
  int result;

  if (linebuf == 0)
  {
    linebuf = (char*)malloc(linemaxlen);
  }

  for (;;)
  {
    if (skip_to_next_directive() == 0)
    {
      return 0;
    }
    c = input();
    while (c == ' ' || c == '\t')
    {
      c = input();
    }
    if (c == 0 || c == EOF)
    {
      return 0;
    }

    /* eat the whole line */
    i = 0;
    linebuf[i++] = '#';
    while (c != 0 && c != EOF && c != '\n')
    {
      if (i >= linemaxlen - 5)
      {
        char* oldlinebuf = linebuf;
        linemaxlen += i + 5;
        linebuf = (char*)realloc(linebuf, linemaxlen);
        if (!linebuf)
        {
          free(oldlinebuf);
          return 0;
        }
      }
      linebuf[i++] = c;
      /* be sure to skip escaped newlines */
      if (c == '\\')
      {
        c = input();
        linebuf[i++] = c;
        if (c == '\r')
        {
          c = input();
          linebuf[i++] = c;
        }
      }
      c = input();
    }
    linebuf[i++] = c;

    result = vtkParsePreprocess_HandleDirective(preprocessor, linebuf);
    if (result != VTK_PARSE_SKIP && result != VTK_PARSE_OK)
    {
      print_preprocessor_error(result, linebuf, i);
    }
    else if (result != VTK_PARSE_SKIP)
    {
      break;
    }
  }

  return 1;
}

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 */
int skip_ahead_multi(const char* strings[])
{
  char textbuf[SKIP_MATCH_MAXLEN + 1];
  int c = 0;
  size_t i;

  for (i = 0; i < (SKIP_MATCH_MAXLEN + 1); i++)
  {
    textbuf[i] = '\0';
  }

  for (;;)
  {
    for (i = 0; i < SKIP_MATCH_MAXLEN; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    if (c == 0 || c == EOF)
    {
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, NULL, 0);
      return 0;
    }

    textbuf[SKIP_MATCH_MAXLEN - 1] = c;

    for (i = 0; strings[i]; i++)
    {
      if (strcmp(&textbuf[SKIP_MATCH_MAXLEN - strlen(strings[i])], strings[i]) == 0)
      {
        break;
      }
    }
    if (strings[i])
    {
      break;
    }
  }

  while (c != 0 && c != EOF && c != '\n')
  {
    c = input();
  }

  return 1;
}

/*
 * Skip ahead until the string is found.
 */
int skip_ahead_until(const char* text)
{
  const char* strings[2];
  strings[0] = text;
  strings[1] = NULL;

  return skip_ahead_multi(strings);
}

/*
 * Called for doxygen C-style comments
 */
void doxygen_comment(void)
{
  char linetext[256];
  int savelineno = yylineno;
  int asterisk, isfirstline = 1;
  int type = DoxygenComment;
  int l = 0, i = 0, base = yyleng;
  int c1 = 0, c2 = input();
  for (l = 0; l < yyleng; l++)
  {
    linetext[l] = yytext[l];
  }
  if (l > 0 && yytext[l - 1] == '<')
  {
    type = TrailingComment;
  }
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (l < 256)
    {
      linetext[l++] = (char)c2;
    }
    if (c2 == '\n' || (c1 == '*' && c2 == '/'))
    {
      if (l >= 2 && linetext[l - 2] == '*' && linetext[l - 1] == '/')
      {
        l -= 2;
      }
      while (l > 0 &&
        (linetext[l - 1] == '\n' || linetext[l - 1] == '\r' || linetext[l - 1] == '\t' ||
          linetext[l - 1] == ' '))
      {
        l--;
      }
      if (!isfirstline)
      {
        /* reduce the base indentation if chars occur before base */
        asterisk = 0;
        for (i = yyleng - 3; i < base && i < l; i++)
        {
          if (linetext[i] == '*' && asterisk == 0)
          {
            asterisk = 1;
          }
          else if (linetext[i] != ' ')
          {
            break;
          }
        }
        if (i > yyleng - 3 && i < l && linetext[i] != ' ' && linetext[i - 1] == ' ')
        {
          i--;
        }
        base = i;
      }
      if (l > base)
      {
        i = base;
        l -= base;
        addCommentLine(&linetext[i], l, type);
      }
      else if (c1 != '*' || c2 != '/')
      {
        addCommentLine("", 0, type);
      }
      if (isfirstline)
      {
        isfirstline = 0;
        base = 256;
      }
      l = 0;
      if (c1 == '*' && c2 == '/')
      {
        break;
      }
    }
    c1 = c2;
    c2 = input();
  }
}

/*
 * Called for //! and /// doxygen comments (handles just one line)
 */
void doxygen_cpp_comment(void)
{
  int type = DoxygenComment;
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  while (pos < yyleng && yytext[pos - 1] == '/' && yytext[pos] == '/')
    pos++;
  if (pos < yyleng && yytext[pos] == '!')
    pos++;
  if (pos < yyleng && yytext[pos] == '<')
  {
    pos++;
    type = TrailingComment;
  }
  addCommentLine(&yytext[pos], yyleng - pos, type);
}

/*
 * Called for ///@{
 */
void doxygen_group_start(void)
{
  /* Set the "ingroup" marker */
  setCommentMemberGroup(1);
}

/*
 * Called for ///@}
 */
void doxygen_group_end(void)
{
  /* Clear the "ingroup" marker */
  setCommentMemberGroup(0);
}

/*
 * Called for // Description:
 */
void vtk_comment(void)
{
  setCommentState(NormalComment);
}

/*
 * Called for // .NAME
 */
void vtk_name_comment(void)
{
  int pos = 1;
  while (yytext[pos - 1] != 'M' || yytext[pos] != 'E')
  {
    pos++;
  }
  pos++;
  setCommentState(NameComment);
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called for // .SECTION
 */
void vtk_section_comment(void)
{
  int pos = 1;
  while (yytext[pos - 1] != 'O' || yytext[pos] != 'N')
  {
    pos++;
  }
  pos++;
  if (pos < yyleng && yytext[pos] == ' ')
  {
    pos++;
  }

  if (yyleng - pos >= 11 && strncmp(&yytext[pos], "Description", 11) == 0)
  {
    setCommentState(DescriptionComment);
  }
  else if (yyleng - pos >= 8 &&
    (strncmp(&yytext[pos], "See Also", 8) == 0 || strncmp(&yytext[pos], "see also", 8) == 0))
  {
    setCommentState(SeeAlsoComment);
  }
  else if (yyleng - pos >= 7 && strncmp(&yytext[pos], "Caveats", 7) == 0)
  {
    setCommentState(CaveatsComment);
  }
  else
  {
    cpp_comment_line();
  }
}

/*
 * Called for each line that has a C++ comment but no code, unless the
 * comment is recognized as beginning a VTK or doxygen comment.
 */
void cpp_comment_line(void)
{
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called whenever a blank line is encountered.
 */
void blank_line(void)
{
  commentBreak();
}

/*
 * Convert a raw string into a non-raw string.
 */
const char* raw_string(const char* begin, int* has_ud_suffix)
{
  int savelineno = yylineno;
  char* textbuf;
  int c = 0;
  const char* delim;
  const char* cp = begin;
  char* dp;
  char* result;
  size_t i, j, n;
  size_t m = 1024;

  result = (char*)malloc(m);
  dp = result;

  while (*cp != '\"')
  {
    *dp++ = *cp++;
  }
  --dp;
  *dp++ = *cp++;

  delim = cp;

  for (n = 0;; n++)
  {
    if (delim[n] == '(')
    {
      break;
    }
  }

  textbuf = (char*)malloc(n + 1);

  for (i = 0; i < n + 1; i++)
  {
    c = input();
    textbuf[i] = c;
  }

  while (c != EOF)
  {
    if (textbuf[0] == ')' && (n == 0 || strncmp(&textbuf[1], delim, n) == 0))
    {
      break;
    }

    j = dp - result;
    if (j > m - 8)
    {
      m += 1024;
      result = (char*)realloc(result, m);
      if (!result)
      {
        print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
        exit(1);
      }
      dp = result + j;
    }

    if ((*textbuf >= ' ' && *textbuf <= '~') || (*textbuf & 0x80) != 0)
    {
      *dp++ = *textbuf;
    }
    else
      switch (*textbuf)
      {
        case '\a':
          *dp++ = '\\';
          *dp++ = 'a';
          break;
        case '\b':
          *dp++ = '\\';
          *dp++ = 'b';
          break;
        case '\f':
          *dp++ = '\\';
          *dp++ = 'f';
          break;
        case '\n':
          *dp++ = '\\';
          *dp++ = 'n';
          break;
        case '\r':
          *dp++ = '\\';
          *dp++ = 'r';
          break;
        case '\t':
          *dp++ = '\\';
          *dp++ = 't';
          break;
        case '\v':
          *dp++ = '\\';
          *dp++ = 'v';
          break;
        case '\\':
          *dp++ = '\\';
          *dp++ = '\\';
          break;
        case '\'':
          *dp++ = '\\';
          *dp++ = '\'';
          break;
        case '\"':
          *dp++ = '\\';
          *dp++ = '\"';
          break;
        default:
          sprintf(dp, "\\%3.3o", *textbuf);
          dp += 4;
          break;
      }

    for (i = 0; i < n; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    textbuf[n] = c;
  }

  if (c == EOF || '\"' != input())
  {
    yylineno = savelineno;
    print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Unterminated raw string.", 24);
    exit(1);
  }

  *dp++ = '\"';

  c = input();
  if (vtkParse_CharType(c, CPRE_ID))
  {
    *has_ud_suffix = 1;
    do
    {
      *dp++ = c;
      c = input();
    } while (vtkParse_CharType(c, CPRE_XID));
  }
  else
  {
    *has_ud_suffix = 0;
  }
  unput(c);

  *dp = '\0';
  cp = vtkstrdup(result);
  free(result);
  free(textbuf);

  return cp;
}

/*
 * buffer stack, used for macro expansion and include files
 */
static size_t buffer_stack_size = 0;
static YY_BUFFER_STATE* buffer_stack = NULL;

/*
 * push the current buffer onto the buffer stack.
 */
void push_buffer(void)
{
  size_t n = buffer_stack_size;
  if (buffer_stack == NULL)
  {
    buffer_stack = (YY_BUFFER_STATE*)malloc(4 * sizeof(YY_BUFFER_STATE));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    buffer_stack = (YY_BUFFER_STATE*)realloc(buffer_stack, 2 * n * sizeof(YY_BUFFER_STATE));
    if (!buffer_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  buffer_stack[buffer_stack_size++] = YY_CURRENT_BUFFER;
}

/*
 * pop the buffer stack and restore the previous buffer
 */
int pop_buffer(void)
{
  if (in_macro())
  {
    pop_macro();
  }
  else
  {
    pop_include();
  }
  if (buffer_stack_size == 0)
  {
    return 0;
  }
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yy_switch_to_buffer(buffer_stack[--buffer_stack_size]);
  if (buffer_stack_size == 0)
  {
    free(buffer_stack);
    buffer_stack = NULL;
  }
  return 1;
}

/*
 * include stack, to tell what include is being evaluated
 */
static size_t include_stack_size = 0;
static FileInfo** include_stack = NULL;
static int* lineno_stack = NULL;

/*
 * push the current include onto the include stack.
 */
void push_include(const char* filename)
{
  FileInfo* file_info = NULL;
  int same_file = 0;
  size_t n = include_stack_size;

  if (include_stack == NULL)
  {
    include_stack = (FileInfo**)malloc(4 * sizeof(FileInfo*));
    lineno_stack = (int*)malloc(4 * sizeof(int));
  }

  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    include_stack = (FileInfo**)realloc(include_stack, 2 * n * sizeof(FileInfo*));
    if (!include_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
    lineno_stack = (int*)realloc(lineno_stack, 2 * n * sizeof(int));
    if (!lineno_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }

  lineno_stack[include_stack_size] = yyget_lineno();
  yyset_lineno(0);
  include_stack[include_stack_size++] = data;

  /* if the file is including itself */
  if (filename == data->FileName ||
    (filename != 0 && data->FileName != 0 && strcmp(filename, data->FileName) == 0))
  {
    same_file = 1;
  }

  /* make a new fileinfo, but only if we are in the base namespace
   * and only if the only items added so far are constants */
  if (!same_file && currentNamespace == data->Contents &&
    data->Contents->NumberOfItems == data->Contents->NumberOfConstants)
  {
    file_info = (FileInfo*)malloc(sizeof(FileInfo));
    vtkParse_InitFile(file_info);
    file_info->FileName = vtkstrdup(filename);
    file_info->Contents = (NamespaceInfo*)malloc(sizeof(NamespaceInfo));
    vtkParse_InitNamespace(file_info->Contents);
    vtkParse_AddIncludeToFile(data, file_info);
    file_info->Strings = data->Strings;
    data = file_info;
    currentNamespace = file_info->Contents;
  }
}

/*
 * pop the include stack
 */
void pop_include(void)
{
  if (include_stack_size > 0)
  {
    --include_stack_size;
    fclose(yyin);
    yyset_lineno(lineno_stack[include_stack_size]);
    if (data != include_stack[include_stack_size])
    {
      data = include_stack[include_stack_size];
      currentNamespace = data->Contents;
    }
  }
}

/*
 * macro stack, to tell what macro is being evaluated
 */
static size_t macro_stack_size = 0;
static MacroInfo** macro_stack = NULL;

/*
 * push the current macro onto the macro stack.
 */
void push_macro(MacroInfo* macro)
{
  size_t n = macro_stack_size;
  if (macro_stack == NULL)
  {
    macro_stack = (MacroInfo**)malloc(4 * sizeof(MacroInfo*));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    macro_stack = (MacroInfo**)realloc(macro_stack, 2 * n * sizeof(MacroInfo*));
    if (!macro_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  macro_stack[macro_stack_size++] = macro;
  if (macro)
  {
    macro->IsExcluded = 1;
    if (macro_stack_size == 1)
    {
      macroName = macro->Name;
      macroUsed = 0;
      macroEnded = 0;
    }
  }
}

/*
 * pop the macro stack
 */
void pop_macro(void)
{
  MacroInfo* macro;

  if (macro_stack_size > 0)
  {
    macro = macro_stack[--macro_stack_size];
    if (macro)
    {
      macro->IsExcluded = 0;
    }
    if (macro_stack_size == 0)
    {
      free(macro_stack);
      macro_stack = NULL;
    }
  }
  macroEnded = 1;
}

/*
 * are we currently processing a macro?
 */
int in_macro(void)
{
  return (macro_stack_size > 0);
}

/*
 * print a preprocessor error code with filename and line number.
 */
void print_preprocessor_error(int result, const char* cp, size_t n)
{
  const char* text = "";

  switch (result)
  {
    case VTK_PARSE_OK:
    case VTK_PARSE_SKIP:
      return;
    case VTK_PARSE_PREPROC_DOUBLE:
      text = "double in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_FLOAT:
      text = "float in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_STRING:
      text = "string in preprocessor conditional";
      break;
    case VTK_PARSE_MACRO_UNDEFINED:
      text = "undefined macro";
      break;
    case VTK_PARSE_MACRO_REDEFINED:
      text = "redefined macro";
      break;
    case VTK_PARSE_FILE_NOT_FOUND:
      text = "file not found";
      break;
    case VTK_PARSE_FILE_OPEN_ERROR:
      text = "can\'t open file";
      break;
    case VTK_PARSE_FILE_READ_ERROR:
      text = "input/output error";
      break;
    case VTK_PARSE_MACRO_NUMARGS:
      text = "wrong number of macro args";
      break;
    case VTK_PARSE_SYNTAX_ERROR:
      text = "syntax error";
      break;
    case VTK_PARSE_OUT_OF_MEMORY:
      text = "out of memory";
      break;
  }

  /* be silent about missing include files */
  if (result == VTK_PARSE_FILE_NOT_FOUND)
  {
    return;
  }

  print_parser_error(text, cp, n);
}

/*
 * print an error with filename and line number.
 */
void print_parser_error(const char* text, const char* cp, size_t n)
{
  size_t j = 0;
  const char* fn = "(none)";

  if (CommandName)
  {
    fprintf(yyout, "%s: ", CommandName);
  }

  if (data->FileName)
  {
    fn = data->FileName;
  }
  fprintf(yyout, "In %s:", fn);
  for (j = 0; j < include_stack_size; j++)
  {
    fprintf(yyout, "%i:\nIn %s:", lineno_stack[j], include_stack[j]->FileName);
  }
  fprintf(yyout, "%i:", yylineno);

  if (cp)
  {
    fprintf(yyout, " %s: %*.*s\n", text, (int)n, (int)n, cp);
  }
  else if (text)
  {
    fprintf(yyout, " %s.\n", text);
  }
  else
  {
    fprintf(yyout, "\n");
  }
}

/*
 * Execute a preprocessor directive.
 */
void preprocessor_directive(const char* text, size_t l)
{
  int result = 0;
  size_t n = 0;
  const char* cp = text;
  const char* ep = text + l;
  const char* directive = NULL;

  /* find the directive, store its length in "n" */
  while (*cp == ' ' || *cp == '\t')
  {
    cp++;
  }
  if (*cp == '#')
  {
    cp++;
  }
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }
  directive = cp;
  while (*cp >= 'a' && *cp <= 'z' && cp < ep)
  {
    cp++;
  }
  n = cp - directive;
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }

  if (n == 7 && strncmp(directive, "include", n) == 0)
  {
    /* include files */
    int already_loaded = 0;
    if (*cp == '<' || *cp == '\"')
    {
      /* if asked to recurse into header files */
      if (Recursive && ep - cp > 3)
      {
        const char* dp;
        dp = vtkParsePreprocess_FindIncludeFile(preprocessor, &cp[1],
          (*cp != '\"' ? VTK_PARSE_SYSTEM_INCLUDE : VTK_PARSE_SOURCE_INCLUDE), &already_loaded);
        if (dp)
        {
          yyin = vtkParse_FileOpen(dp, "r");
          if (yyin)
          {
            push_include(dp);
            push_buffer();
            yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
            return;
          }
        }
      }
    }
  }

  /* let the preprocessor handle the directive */
  result = vtkParsePreprocess_HandleDirective(preprocessor, text);

  if (result == VTK_PARSE_SKIP)
  {
    skip_conditional_block();
  }
  else if (result != VTK_PARSE_OK)
  {
    print_preprocessor_error(result, text, l);
    if ((result & VTK_PARSE_FATAL_ERROR) != 0)
    {
      exit(1);
    }
  }
  else if (n == 6 && strncmp(directive, "define", n) == 0)
  {
    closeComment();
    if (ep - cp > 4 && strncmp(cp, "VTK", 3) == 0)
    {
      /* macros that start with "VTK" */
      MacroInfo* macro;

      macro = vtkParsePreprocess_GetMacro(preprocessor, cp);
      if (macro && macro->Definition && !macro->IsFunction)
      {
        /* if macro evaluates to a constant, add it as a constant */
        macro->IsExcluded = 1;
        if (guess_constant_type(macro->Definition) == 0)
        {
          result = VTK_PARSE_MACRO_UNDEFINED;
        }
        macro->IsExcluded = 0;
        if (result < VTK_PARSE_MACRO_UNDEFINED)
        {
          add_constant(vtkstrdup(macro->Name), vtkstrdup(macro->Definition), 0, 0, NULL, 1);
        }
      }
    }
  }
}
